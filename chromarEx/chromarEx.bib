@incollection{gibbons_functional_2015,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Functional {Programming} for {Domain}-{Specific} {Languages}},
	copyright = {©2015 Springer International Publishing Switzerland},
	isbn = {978-3-319-15939-3 978-3-319-15940-9},
	url = {http://link.springer.com/chapter/10.1007/978-3-319-15940-9_1},
	abstract = {Domain-specific languages are a popular application area for
                  functional programming; and conversely, functional programming
                  is a popular implementation vehicle for domain-specific
                  languages—at least, for embedded ones. Why is this? The appeal
                  of embedded domain-specific languages is greatly enhanced by
                  the presence of convenient lightweight tools for defining,
                  implementing, and optimising new languages; such tools
                  represent one of functional programming’s strengths. In these
                  lectures we discuss functional programming techniques for
                  embedded domain-specific languages; we focus especially on
                  algebraic datatypes and higher-order functions, and their
                  influence on deep and shallow embeddings.},
	language = {en},
	number = {8606},
	urldate = {2017-02-23},
	booktitle = {Central {European} {Functional} {Programming} {School}},
	publisher = {Springer International Publishing},
	author = {Gibbons, Jeremy},
	editor = {Zsók, Viktória and Horváth, Zoltán and Csató, Lehel},
	year = {2015},
	doi = {10.1007/978-3-319-15940-9_1},
	keywords = {Compilers, Interpreters, Logics and Meanings of Programs,
                  Programming Languages, Programming Techniques, Software
                  Engineering},
	pages = {1--28}
}


@inproceedings{mainland_why_2007,
	address = {New York, NY, USA},
	series = {Haskell '07},
	title = {Why {It}'s {Nice} to {Be} {Quoted}: {Quasiquoting} for {Haskell}},
	isbn = {978-1-59593-674-5},
	shorttitle = {Why {It}'s {Nice} to {Be} {Quoted}},
	url = {http://doi.acm.org/10.1145/1291201.1291211},
	doi = {10.1145/1291201.1291211},
	abstract = {Quasiquoting allows programmers to use domain specific
                  syntax to construct program fragments. By providing concrete
                  syntax for complex data types, programs become easier to read,
                  easier to write, and easier to reason about and
                  maintain. Haskell is an excellent host language for embedded
                  domain specific languages, and quasiquoting ideally
                  complements the language features that make Haskell perform so
                  well in this area. Unfortunately, until now no Haskell
                  compiler has provided support for quasiquoting. We present an
                  implementation in GHC and demonstrate that by leveraging
                  existing compiler capabilities, building a full quasiquoter
                  requires little more work than writing a parser. Furthermore,
                  we provide a compile-time guarantee that all quasiquoted data
                  is type-correct.},
	urldate = {2017-02-23},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} {Workshop} on {Haskell} {Workshop}},
	publisher = {ACM},
	author = {Mainland, Geoffrey},
	year = {2007},
	keywords = {meta programming, quasiquoting},
	pages = {73--82},
	annote = {bibtex: mainland\_why\_2007}
}


@inproceedings{wan_functional_2000,
	address = {New York, NY, USA},
	series = {{PLDI} '00},
	title = {Functional {Reactive} {Programming} from {First} {Principles}},
	isbn = {978-1-58113-199-4},
	url = {http://doi.acm.org/10.1145/349299.349331},
	doi = {10.1145/349299.349331},
	abstract = {Functional Reactive Programming, or FRP, is a general
                  framework for programming hybrid systems in a high-level,
                  declarative manner. The key ideas in FRP are its notions of
                  behaviors and events. Behaviors are time-varying, reactive
                  values, while events are time-ordered sequences of
                  discrete-time event occurrences. FRP is the essence of Fran, a
                  domain-specific language embedded in Haskell for programming
                  reactive animations, but FRP is now also being used in vision,
                  robotics and other control systems applications. In this paper
                  we explore the formal semantics of FRP and how it relates to
                  an implementation based on streams that represent (and
                  therefore only approximate) continuous behaviors. We show
                  that, in the limit as the sampling interval goes to zero, the
                  implementation is faithful to the formal, continuous
                  semantics, but only when certain constraints on behaviors are
                  observed. We explore the nature of these constraints, which
                  vary amongst the FRP primitives. Our results show both the
                  power and limitations of this approach to language design and
                  implementation. As an example of a limitation, we show that
                  streams are incapable of representing instantaneous predicate
                  events over behaviors.},
	urldate = {2017-01-25},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 2000 {Conference} on
                  {Programming} {Language} {Design} and {Implementation}},
	publisher = {ACM},
	author = {Wan, Zhanyong and Hudak, Paul},
	year = {2000},
	keywords = {frp, haskell},
	pages = {242--252}
}


@article{honorato-zimmer_chromar_2017,
	title = {Chromar, a language of parameterised agents},
	journal = {Theoretical Computer Science},
	author = {Honorato-Zimmer, Ricardo and Millar, Andrew J and Plotkin,
                  Gordon D and Zardilis, Argyris},
	year = {2017}
}

@article{honorato-zimmer_chromar_2018,
	series = {7th {International} {Workshop} on {Static} {Analysis} and
                  {Systems} {Biology} ({SASB} 2016)},
	title = {Chromar, a {Rule}-based {Language} of {Parameterised}
                  {Objects}},
	volume = {335},
	issn = {1571-0661},
	url =
                  {http://www.sciencedirect.com/science/article/pii/S1571066118300100},
	doi = {10.1016/j.entcs.2018.03.008},
	abstract = {Modelling in biology becomes necessary when systems are
                  complex but the more complex the systems are the harder the
                  models become to read. The most common ways of writing models
                  are by writing reactions on discrete, typed objects
                  (e.g. molecules of different species), or writing rate
                  equations for the populations of such species. One problem (1)
                  with those approaches is that the number of species and
                  reactions is often so large that the model cannot be
                  realistically enumerated. Another problem (2) is that the
                  number of species and reactions is fixed, whereas biology
                  often grows new compartments which means new reactions and
                  species. Here we develop an extension to the representation of
                  reactions where the objects carry variables that are defined
                  by their type (for example objects of type Leaf all have a
                  Mass variable). The dynamics are defined by rules about types,
                  which means they work for all objects of that type. This
                  compact representation solves problem 1. If we think of the
                  object variables as the analogue of reaction/rate equation
                  species, creating a new object of some type means we are also
                  creating new species (solving problem 2). We also developed an
                  embedding of Chromar in the programming language Haskell and
                  showed its applicability to two examples. Having a more
                  compact representation can help make models a tool for
                  knowledge representation and exchange instead of just a
                  simulation input. Embedding Chromar in a general purpose
                  programming language lifts some of the constraints of
                  modelling languages while still maintaining the naturalness of
                  a domain-specific language.},
	urldate = {2018-06-15},
	journal = {Electronic Notes in Theoretical Computer Science},
	author = {Honorato-Zimmer, Ricardo and Millar, Andrew J. and Plotkin,
                  Gordon D. and Zardilis, Argyris},
	month = apr,
	year = {2018},
	keywords = {rule-based modelling, systems biology, representation,
                  stochastic},
	pages = {49--66},
	file = {ScienceDirect Full Text
                  PDF:/Users/s1437009/Zotero/storage/4L77XG5N/Honorato-Zimmer et
                  al. - 2018 - Chromar, a Rule-based Language of Parameterised
                  Ob.pdf:application/pdf;ScienceDirect
                  Snapshot:/Users/s1437009/Zotero/storage/SZWDN27B/S1571066118300100.html:text/html}
}

@incollection{jensen_coloured_1987,
	title = {Coloured petri nets},
	booktitle = {Petri nets: central models and their properties},
	publisher = {Springer},
	author = {Jensen, Kurt},
	year = {1987},
	pages = {248--299}
}


@inproceedings{budiu_compiler_2013,
	title = {The compiler forest},
	booktitle = {European {Symposium} on {Programming}},
	publisher = {Springer},
	author = {Budiu, Mihai and Galenson, Joel and Plotkin, Gordon D},
	year = {2013},
	pages = {21--40}
}


@article{buneman_comprehension_1994,
	title = {Comprehension syntax},
	volume = {23},
	number = {1},
	journal = {ACM Sigmod Record},
	author = {Buneman, Peter and Libkin, Leonid and Suciu, Dan and Tannen, Val and Wong, Limsoon},
	year = {1994},
	pages = {87--96}
}

@inproceedings{oury_coloured_2011,
	title = {Coloured stochastic multilevel multiset rewriting},
	booktitle = {Proceedings of the 9th {International} {Conference} on
                  {Computational} {Methods} in {Systems} {Biology}},
	publisher = {ACM},
	author = {Oury, Nicolas and Plotkin, Gordon D},
	year = {2011},
	pages = {171--181}
}

@article{mjolsness2006stochastic,
  title={Stochastic process semantics for dynamical grammars},
  author={Mjolsness, Eric and Yosiphon, Guy},
  journal={Annals of Mathematics and Artificial Intelligence},
  volume={47},
  number={3-4},
  pages={329--395},
  year={2006},
  publisher={Springer}
}


@inproceedings{john_biochemical_2011,
	title = {Biochemical reaction rules with constraints},
	booktitle = {European {Symposium} on {Programming}},
	publisher = {Springer},
	author = {John, Mathias and Lhoussaine, Cédric and Niehren, Joachim and
                  Versari, Cristian},
	year = {2011},
	pages = {338--357}
}


@incollection{danos_scalable_2007,
	title = {Scalable simulation of cellular signaling networks},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer},
	author = {Danos, Vincent and Feret, Jérôme and Fontana, Walter and Krivine, Jean},
	year = {2007},
	pages = {139--157}
}


@article{blinov_bionetgen:_2004,
	title = {{BioNetGen}: software for rule-based modeling of signal
                  transduction based on the interactions of molecular domains},
	volume = {20},
	number = {17},
	journal = {Bioinformatics},
	author = {Blinov, Michael L and Faeder, James R and Goldstein, Byron and
                  Hlavacek, William S},
	year = {2004},
	pages = {3289--3291}
}


@article{pedersen_high-level_2015,
	title = {A high-level language for rule-based modelling},
	volume = {10},
	number = {6},
	journal = {PloS one},
	author = {Pedersen, Michael and Phillips, Andrew and Plotkin, Gordon D},
	year = {2015},
	pages = {e0114296}
}


@article{lopez_programming_2013,
	title = {Programming biological models in {Python} using {PySB}},
	volume = {9},
	number = {1},
	journal = {Molecular systems biology},
	author = {Lopez, Carlos F and Muhlich, Jeremy L and Bachman, John A and Sorger, Peter K},
	year = {2013},
	pages = {646}
}