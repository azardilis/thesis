\documentclass[phd]{infthesis}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[british]{babel}
\usepackage{microtype}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage[english=british,autopunct=false]{csquotes}
\usepackage[natbib=true,style=authoryear-comp,maxbibnames=6]{biblatex}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{wrapfig}
\usepackage{xfrac}
\usepackage{xspace}
\usepackage{mathcommon}
\usepackage[sc]{mathpazo}
\usepackage{hyperref}
\usepackage{expl3}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{mathpartir}

\frenchspacing

% Bibliography
\addbibresource{chromarForm.bib}
\bibliography{chromarForm}

% Text
\newcommand{\ie}{i.e.\xspace}
\newcommand{\eg}{e.g.\xspace}

% Referencing
\newcommand{\chp}[1]{\S\ref{chp:#1}}
\newcommand{\sct}[1]{\S\ref{sec:#1}}
\newcommand{\ssec}[1]{\S\ref{subsec:#1}}
\newcommand{\eqn}[1]{Eq.~\ref{eq:#1}}
\newcommand{\eqns}[2]{Eq. \ref{eq:#1} and \ref{eq:#2}}
\newcommand{\lem}[1]{Lemma~\ref{lemma:#1}}
\newcommand{\lems}[2]{Lemmas \ref{lemma:#1} and \ref{lemma:#2}}
\newcommand{\thm}[1]{Th.~\ref{thm:#1}}
\newcommand{\fig}[1]{Fig.~\ref{fig:#1}}
\newcommand{\diagram}[1]{diagram~\ref{eq:#1}}
\newcommand{\app}[1]{Appendix~\ref{app:#1}}
\newcommand{\mcite}[1]{\textcolor{gray}{#1}} % missing cite
\newcommand{\defn}[1]{Def.~\ref{def:#1}}
\newcommand{\prop}[1]{Prop.~\ref{prop:#1}}

% Math
\renewcommand{\tuple}[1]{\left(#1\right)}
\DeclareMathOperator*{\expn}{exp}
\renewcommand*{\exp}[1]{e^{\,#1}} % \mathrm{e}^{#1}}
\renewcommand{\qedsymbol}{\ensuremath{\blacksquare}}
\newcommand{\partialto}{\rightharpoonup}
\newcommand{\id}{\vec{1}} % identity function
\newcommand{\mr}[1]{\mathrm{#1}}

\newcommand{\den}[1]{\llbracket #1 \rrbracket}
\newcommand{\m}[1]{\{\!| #1 |\!\}}
\newcommand{\M}[1]{\mathcal{#1}}
\newcommand{\MS}[0]{\mathrm{M}}
\newcommand{\SQ}[0]{\mathrm{S}}
\newcommand{\s}[1]{\underline{#1}}
\newcommand{\G}[0]{\Gamma}
\newcommand{\D}[0]{\Delta}
\newcommand{\mytt}{t\!t}
\newcommand{\myff}{f\!\!f}

\newcommand{\V}{\mathrm{V}}

\newcommand{\sel}{\mathrm{sel}}
\newcommand{\fold}{\mathrm{fold}}

\newcommand{\ms}{\mathrm{ms}}


\newtheorem{mydef}{Definition}
\def\dotminus{\mathbin{\ooalign{\hss\raise1ex\hbox{.}\hss\cr
  \mathsurround=0pt$-$}}}
\setlength{\tabcolsep}{8pt}
\renewcommand{\arraystretch}{1.0}

\newcommand{\match}{m}
\newcommand{\up}[1]{\uparrow\! #1}

\newcommand{\n}{\mathrm{n}}


% Other stuff
\newcommand{\maybe}[1]{\textcolor{gray}{#1}}
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}

% rules
\newcommand{\ar}[2]{\mr{#1} \! = \! {#2}}

\setlength{\tabcolsep}{8pt}
\renewcommand{\arraystretch}{1.2}

\def\changemargin#1#2{\list{}{\rightmargin#2\leftmargin#1}\item[]}
\let\endchangemargin=\endlist 

\begin{document}

\chapter{Chromar: formal definition}
\label{chp:chromarForm}
In the previous chapter we gave some example illustrating how Chromar works. In
this chapter we formally introduce the syntax and semantics of Chromar.  Most of
the work in this chapter appears in \citet{}.

\section{Abstract syntax of basic Chromar}
\label{sec:syntax}
We next define the abstract syntax of basic Chromar.

Regarding notation, we write $\s{a}$ for a possibly empty sequence of objects,
whose typical elements are given by mathematical expressions $a$. We write
$\s{a}.i$ for the $i$th element of the sequence and $|\s{a}|$ for its length,
and write the empty sequence as $\varepsilon$ and use commas for the composition
of sequences.  We assume we have a countable set of names $N$ ranged over by
$n_a, n_f, id$ where $n_a$ will be used for agent names, $n_f$ for attribute
names, and $id$ for variables.

For generality we assume that basic Chromar is parameterised by a set $E$ of
\emph{expressions} (an expression language) ranged over by $e, e_r, e_c$, and
including variables, together with a set of \emph{base types}
$B \supseteq \{\mathrm{bool}, \mathrm{real} \}$ ranged over by $b$; base types are used to
specify agent attributes (we use $e_c$ to indicate condition expressions and
$e_r$ to indicate rate expressions).
%
We further have \emph{agent types} $\s{n_f:b}$ that are sequences of distinct
typed attribute names.

We may say that basic Chromar is \emph{abstract} in that no choice is made of an
expression language and its types; the same holds of extended Chromar
(Section~\ref{sec:extSyntax}).  In contrast, in a \emph{concrete} realisation of
the language a particular choice is made.  For example, the Haskell embedding of
extended Chromar (Section~\ref{sec:impl}) provides such a concrete realisation,
where the expressions and types are the Haskell expressions and types.

A \emph{base type environment} $\G = \s{id:b}$ is a sequence of variable type
bindings, and an \emph{agent type environment} $\D = \s{id:at}$ is a sequence of
agent type bindings; we require that the variables in environments are distinct.
We write $\G[\G']$ for the new base type environment produced by extending or
overriding $\G$ with new type bindings $\G'$, and define $\D[\D']$ similarly.

Turning to typing, as regards the expression language we assume we have typing
axioms of the form $\G \vdash e : b$ that assign unique base types to expressions in
some base type environments, with the following being the only axiom for
variables:
 \[\G \vdash id:b  \quad (id:b \, \in \, \G)\]

 The syntax and typing rules for the rest of basic Chromar are given in
 Figure~\ref{fig:syntax}. We next go through the various syntactic constructs
 and explain their syntax and typing rules:

\begin{figure}[!htbp]
\centering
\resizebox{0.9\linewidth}{!}{%
\begin{tabularx}{\textwidth}{llr|c} 
\toprule
\addlinespace[0.25cm]
&\textsf{\emph{Syntax}} & & \textsf{\emph{Typing rules}} \\ 
& & & \\
$a_d ::=$ & $\mathbf{agent} \; n_a(\s{n_f:b})$ &\textsf{agent decl}
%
& $\inferrule*[Right=(T-Intro)]{}{%\G 
\vdash \mathbf{agent} \; n_a(\s{n_f :b}) : (n_a : \s{n_f : b})}$\\
& & &  (all $n_f$s distinct) \\
& & & \\
$a_l ::=$ & $n_a(\s{n_f=id})$ & \textsf{left agent} &
%
$\inferrule*[Right=(T-L-agent)]{}{\D \vdash n_a(\s{n_f=id}) : (\s{id:b})} $\\
& & \textsf{expr}& ($n_a: (\s{n_f:b}) \in  \D$, all $id$s distinct) \\
& & & \\
$a_r::=$ & $n_a(\s{n_f=e})$ &\textsf{right agent} & 
$\inferrule*[Right=(T-R-agent)]{\G \vdash \s{e :b}}
{\G \,|\, \D \vdash n_a(\s{n_f=e})}$ \\
& & \textsf{expr}& ($ n_a : (\s{n_f:b}) \in \D$)\\
& & &\\
$r ::=$& $\s{a_l} \xrightarrow{e_r} \s{a_r} \; [e_c]$ & \textsf{rule expr} &  
%
$\inferrule*[Right=(T-Rule)]{\D \vdash \s{a_l} : \G' \\
 \G[\G']|\D \vdash \s{a_r} \\\\ \G[\G'] \vdash e_r : \mathrm{real}  \\ \G[\G'] \vdash e_c : \mathrm{bool} }{\G \,|\,\D \vdash \s{a_l} \xrightarrow{e_r} \s{a_r} \; [e_c]}$\\
& & & \\
$m ::=$ & $ \s{a_d};  \; \mathbf{init} \, (\s{a_r});\; \s{r}$ & \textsf{model def} & $\inferrule*[Right=(T-Model)]{ \vdash \s{a_d}: \D \\\\ \G \,|\, \D \vdash \s{a_r} \\ \G \,|\, \D \vdash \s{r}}{\G \vdash \s{a_d}; \; \mathbf{init}\, (\s{a_r}); \;   \s{r}}$\\
& & & \\
\addlinespace[0.25cm]
\bottomrule
\end{tabularx}}
\caption{Abstract syntax of Chromar with corresponding typing rules for each syntactic construct}
\label{fig:syntax}
\end{figure}

\subsubsection*{Agent declarations}
Agent declarations $a_d$ define the sequence of typed attributes that all agents
with some name $n_a$ should have (\textsf{agent decl},
Figure~\ref{fig:syntax}). Using the model of the previous section as an example
we had a $\mathrm{Leaf}$ type with attributes $\mathrm{mass}$ of type
$\mathrm{real}$ and $\mathrm{age}$ of type $\mathrm{int}$, that could be
declared with:
$$\mathbf{agent} \; \mathrm{Leaf}(\mathrm{mass}:\mathrm{real}, \mathrm{age}:\mathrm{int})
$$
We use the sequence of typed attributes $\s{n_f:b}$ as the \emph{agent
type}. The typing rule \textsc{T-Intro} produces a new such type binding
associating the agent name to the agent type.

The typing  for models uses the judgment $\vdash \s{a_d}: \D$ for sequences of agent declarations.  This conjoins the agent environments given by the individual agent declarations, provided that no agent name is declared twice. It can be given (inductively on the length of the sequence) by the following axiom and rule:
%
\[\vdash \varepsilon:\varepsilon   \qquad \frac{\vdash a_d: (n_a: \s{n_f:b})  \quad \vdash \s{a'_d}: \D}{\vdash a_d \s{a'_d}: (n_a: \s{n_f:b})  \D} \quad (n_a \mbox{ not bound by } \D)\]

\subsubsection*{Agent expressions}
Agent expressions have a name and a finite sequence of \emph{attribute expressions} of the form $n = e$. (\textsf{agent expr}s, Figure~\ref{fig:syntax}). Agent expressions have a dual role: they are used in the left-hand side of rules as a way of binding values to variables and on the right-hand side of rules as a way of expressing the change in the left-hand side agents. We therefore have two distinct syntactic classes, one for each use:
\begin{itemize}
\item[-] left  agent expressions, $a_l$, where all attribute expressions are of the form $n_f = id$, 
 binding the value of an $n_f$ to a variable $id$, and
\item[-] right agent expressions, $a_r$, where all attribute expressions are of the form $n_f = e$ where  the expression $e$ gives the new value of the attribute $n_f$.
%change in the attribute values.
\end{itemize}



The typing rule \textsc{T-L-agent} introduces new type bindings in the environment for the variables in the left agent expressions according to the agent type. Specifically if we have an agent type in the environment $n_a : (n_1: b_1, \dots, n_k: b_k)$ and a left agent expression $n_a(n_1 = id_1, \dots, n_k = id_k)$, each attribute expression $n_i = id_i$ of the %interface of 
the left agent expression produces a type binding, $id_i:b_i$ according to the agent type; this results  in bindings for the entire expression $(id_1: b_1, \dots, id_k: b_k)$. In Figure~\ref{fig:syntax} we use a shorthand notation where we show the typing for a typical element of each sequence in the rule and then underline for the natural extension to the entire sequence. 

The typing rule \textsc{T-R-agent} makes sure that all expressions assigned to attribute names have the correct type according to the agent type. If we have an agent type binding 
$n_a: (n_1:b_1, \dots, n_k:b_k)$, each attribute expression $n_i = e_i$ of a right agent expression with name $n_a$ should have type $b_i$ in a base type environment $\G$. Again we use the shorthand sequence notation, indicating the rule for typical elements of each sequence and then underlining for the extension to the entire sequence. 

A further restriction implied by the typing rules is that agent expressions should 
%define their interface fully, which means that they should 
define all the attributes indicated by their type.


\subsubsection*{Rule expressions}
Rules, $r$, as we have seen from the examples, have a left-hand side (lhs) consisting of a sequence of left agent expressions, $a_l$, a right-hand side (rhs) consisting of a sequence of right agent expressions, $a_r$, a rate expression $e_r$, and a condition expression $e_c$ (\textsf{rule expr}, Figure~\ref{fig:syntax}). 

The typing rule \textsc{T-Rule} first makes sure via the judgment $\D \vdash \s{a_l} : \G'$ that each left agent expression is well-formed and collects all the basic environments these left agent expressions produce into the environment $\G'$. The judgement can be given (inductively on the length of the sequence) by the following axiom and rule:
%
\[\D \vdash \varepsilon:\varepsilon   \qquad \frac{\D  \vdash a_l : \G  \quad \D  \vdash \s{a'_l}: \G'}{\D  \vdash a_l \s{a'_l}: \G\G'} \quad (\mbox{$\G$ and $\G'$ do not overlap} )\]
%
where two environments are said to \emph{overlap} if there is a variable they both bind.

%agent expressions are well typed (i.e., that agents bind variables to all their attributes, and to no others). Each left agent expression produces a basic type 
%environment bindings for its variables (and no others), and in %GDPwe write
 %$\D \vdash \s{a_l} : \G'$, it is intended that the basic type environment $\G'$ is the concatenation of the environments produced by each element of the 
 %sequence and that no two of these environments bind the same variable (analogously to the case of agent declaration sequences). 
 
 Then, in the environment extended with environment produced by the lhs,  it is checked that the rest of the rule is well formed; in particular, in $ \G[\G']|\D \vdash \s{a_r} $ it is intended that $ \G[\G']|\D \vdash a_r $ holds  for each of the $a_r$.   The extended type environment is needed since the variables of the rule lhs may appear in the rhs, rate, and condition expressions.

\subsubsection*{Model definitions}
A full basic Chromar model $m$ is just a sequence of definitions. We have a sequence of agent declarations, $\s{\mathrm{a_d}}$ followed by the initial state definition, which is just a sequence of right agent expressions, and finally a sequence of rule expressions (\textsf{model def}, Figure~\ref{fig:syntax}). The typing rule \textsc{T-Model} constructs new agent type bindings for all the agent declarations in the model. 
%where $\D$ is obtained by extending the empty binding by the bindings %the concatenation of agent type bindings 
%produced by each agent declaration in the sequence (in more detail, if $\s{a_d} = (a^1_d, \ldots , a^k_d)$, for some $k \geq 0$, and $\vdash a^i_d:  \D^i$, %then $\s{a_d} \vdash  \D$ where $ \D = \varepsilon[ \D^1] \ldots [ \D^k]$).
%
Then in a type environment extended with the defined agent types, the rule checks the initial state definition and the sequence of rules.

\subsection{Syntactic extensions}

Our concrete realisation of Chromar provides two syntactic extensions to the above language which we explain informally below. Chromar with these extensions can be translated to Chromar without them; we omit a formal treatment of the translation.


\subsubsection*{Missing attributes} \label{sec:syntaxExt} We can relax the constraint of having to specify the all the attributes %full interfaces 
of agents in rules by establishing %defining 
a correspondence between left and right-hand sides of rules as follows:
%
\begin{itemize}
\item First, bindings to fresh variable are added to left agents for any missing attributes (these attributes are known from its agent type).
%
%The interface of any agent expressions on the left-hand side of rules with incomplete interfaces is %filled with bindings to fresh names ($id$s) for the attribute names missing in the expression %compared to the attribute names in its agent type. 
%
For example, given an agent type $\mathrm{A}(\mathrm{a}: \mathrm{int}, \mathrm{b} : \mathrm{int})$, the incomplete left agent expression $\mathrm{A}(\mathrm{a}=x)$ becomes $\mathrm{A}(\mathrm{a}=x, \mathrm{b}= y)$, where $y$ is a fresh variable %identifier 
(i.e., one not occurring anywhere else in the lhs). 

\item Then, for every $\s{a_l}.i$ in the left-hand side we establish a positional correspondence with an $\s{a_r}.j$ in the right-hand side, if it exists,
%. Then after the left-hand side agent expressions are completed, we
and complete the corresponding right agent expressions with the same fresh name bindings, if needed.
Any right agent expressions that do not have a corresponding left agent expression need to be fully defined. Continuing with our example, the rule  $\mathrm{A}(\mathrm{a}=x) \rightarrow \mathrm{A}(\mathrm{a}=x+1)$ is completed to $\mathrm{A}(\mathrm{a}=x, \mathrm{b}= y) \rightarrow \mathrm{A}(\mathrm{a}=x + 1, \mathrm{b}= y)$.
\end{itemize}
\subsubsection*{Attribute conditional expressions} 
Condition expressions restrict the applicability of rules by establishing a relation between agents. These relations are often functional dependencies. In such cases, rules can be made easier to read and write by using expressions --- not just variables ---  inside  left agent expressions. 

For example, consider an agent type $\mathrm{A}(\mathrm{a}:\mathrm{int})$. If we want a rule $\mathrm{A}(\dots), \mathrm{A}(\dots) \rightarrow \dots$ to be applicable to only a subset of the $(\mathrm{A}(\dots), \mathrm{A}(\dots))$ pairs in the state,  we might use the condition expression $y = f(x)$ to encode a functional dependency of $y$ on $x$, as in, say, a rule of the form 
%
\[\mathrm{A}(\mathrm{a}=x), \mathrm{A}(\mathrm{a}=y) \rightarrow \dots \; [y = f(x)]\]
%
However,  instead of binding to $y$ in the second left agent expression and then putting the condition $y = f(x)$ at the end, we can write the expression $f(x)$ directly in the left agent expression, obtaining the rule
%
\[\mathrm{A}(\mathrm{a}=x), \mathrm{A}(\mathrm{a}=f(x)) \rightarrow \dots\]


This is just syntactic sugar as any rule left-hand side with such expressions
can be rewritten as a rule with a binding-only left-hand side.  This is done as
follows: any non-variable expression in a left agent expression of the rule is
rewritten as a binding to a fresh variable, and a corresponding equality
condition on this variable is added to the conditional expression of the rule.

\section{Semantics of basic Chromar}\label{sec:semantics}


First, regarding notation, we write $\{ a_1 \mapsto b_1, a_2 \mapsto b_2, \dots \}$ for finite partial maps, from $A$ to $B$, with $a_1, a_2, \dots$ distinct elements of  $A$ and $b_1, b_2, \dots$ in $B$. For two such functions $\sigma$ and $\sigma'$ we write $\sigma[\sigma']$ for the partial function produced by using $\sigma'$ to extend or overwrite the values produced by $\sigma$. 
%
We write $\m{a_1, \dots, a_n}$ for the (finite) multiset of elements of a set $A$ whose elements, counting repetitions, are  $a_i, \ldots, a_n$, and take such multisets to be functions from $A$ to $\mathbb{N}$ counting multiplicities; note that such a function $m$ is zero for all but finitely many arguments, and that $a$ is an element of $m$, written $a \in m$, exactly when $m(a) \neq 0$. We write $\ms(\s{a})$ for the multiset corresponding to the sequence $\s{a}$. We write $m \preceq m'$ for the submultiset relation; this takes multiplicities into account and is defined pointwise. Finally, we  write $\MS[A]$ for the set of all finite multisets over a set $A$ and we write $\SQ[A]$ for the set of all finite sequences over $A$.


For each basic type $b \in B$ we assume we have an associated set of values $\V_b$, including 
$\V_{\mathrm{bool}} = \{\mytt, \myff\} $ for $\mathrm{bool}$ and $\V_{\mathrm{real}} = \mathbb{R}$ for $\mathrm{real}$. We have $\V=\bigcup_{b \in B} \V_b$ the union of these sets of values ranged over by $v$. A \emph{value environment} $\sigma =  id_1: v_1, \dots, id_n: v_n$ with $v_1, \dots, v_n \in \V$ is a sequence of variable value bindings, where the variables are required to be distinct.
%The `comma' operator extends a value environment by adding new bindings to the right. 
%GDPto be unique so 
We will sometimes treat value environments as functions with finite domain; for example to get the value of $id_i$ in $\sigma$ we may write $\sigma(id_i)$. We say that $\sigma= id_1:v_1, \dots, id_n:v_n$ is a $\G$-environment for a base type environment $\G= id_1:b_1, \dots, id_n:b_n$ if  each $id_i:v_i$ in $\sigma$ has an entry for that $id_i$ in $\G$ of the correct type, i.e., $\sigma(id_i) \in \V_{b_i}$. 

Regarding the semantics of expressions, we assume that for each $\G$-environment $\sigma$, base type $b$, and expression $e$ such that $\G\vdash e:b$, the expression has an evaluation $\den{e}_{\G}(\sigma) \in \V_b$ (below, we often omit the environment subscripts on evaluation functions). In particular, for typings  $\G\vdash id:b$ of variables $id$, we assume that $\den{id}_{\G}(\sigma)  = \sigma(id)$.


 We next give the semantics of the other  syntactic constructs of basic Chromar: agent expressions, rules, and models.
\subsubsection*{Agents}
\textit{Agents} are modelled as structures with a name and a finite partial map from attribute names to base values, $ (n_a, \{ n_f \mapsto v \})$. We  write  $\mathrm{Av}$ for the set of such agents, ranged over by $av$. We define the set of \emph{states}, ranged over by $s$, to be $\MS[\mathrm{Av}]$, the set of all finite multisets of agents. 
%
When writing agents in examples, we use left agent expressions, but with constants in place of variables. %identifiers. 
So for example,
we  write  
$ \mathrm{Leaf}(\mathrm{age}=1, \mathrm{mass}=10)$
for the agent
$(\mathrm{Leaf},\{\mathrm{age} \mapsto 1, \mathrm{mass} \mapsto 10\}) $.

%For the semantics of basic Chromar, 
We %need to be able to 
evaluate sequences of left and right agent expressions as states. 
%For the semantics of extended Chromar we also need to be able to evaluate left agent expressions as agents.
%
%To evaluate a left agent expression as an agent, %multisets of agents, 
%suppose we have a typing $\D \vdash n_a(\s{n_f=id}) : \G$ of a left agent expression. Then $\G$ is determined by $\D$, and gives basic 
%types for  the variables in the  left agent expression, and so, for any $\G$-environment, %$\G'$-environment $\sigma$, where $\G$ 
%extends $\G$, 
%we may define the  evaluation 
%$\den{n_a(\s{n_f = id})}_{\D}(\sigma) \in \MS[\mathrm{Av}]$  of the sequence as follows:
%\begin{align*}
%\den{n_a(\s{n_f = id})}_{\D}(\sigma) = n_a(\s{n_f =  \sigma(id))}
%\end{align*}
%
%To evaluate 
For %sequences of 
left agent expressions, %as states, %multisets of agents, 
suppose we have a typing $\D \vdash \s{n_a(\s{n_f=id})} : \G$ of a sequence of left agent expressions. Then $\G$ is determined by $\D$, and gives basic types for the variables in the various  left agent expressions (and no more). So, for any $\G$-environment $\sigma$ we may define the  evaluation $\den{\s{n_a(\s{n_f = id})}}_{\D}(\sigma) \in \MS[\mathrm{Av}]$  of the sequence as follows:
%GDPan evaluation function $\den{\;}_{\G}(\sigma) : \SQ[\mathrm{A_l}] \rightarrow \MS[\mathrm{Av}]$ as follows:
\begin{align*}
\den{\s{n_a(\s{n_f = id})}}_{\D}(\sigma) = \ms(\s{n_a(\s{n_f =  \sigma(id)})} 
\end{align*}


%GDP note above change For any $\G$-environment $\sigma$ and $\D$-environment $\sigma'$ we define an evaluation function $\den{\;}(\sigma, \sigma') : \SQ[\mathrm{A_l}] \rightarrow 
%\MS[\mathrm{Av}]$ as follows:
%\begin{align*}
%\den{\s{n_a(\s{n_f = id})}}(\sigma, \sigma') = MS(\s{n_a(\s{n_f = \sigma, \sigma'(id)})} 
%\end{align*}


%Similarly to evaluate 
For %sequences of 
right agent expressions, %as states, %to multisets of agents, 
suppose that we have a typing $\G \,|\, \D \vdash \s{n_a(\s{n_f = e})}$ of a sequence of right agent expressions. Then for any $\G$-environment $\sigma$ we define the evaluation  $\den{\s{n_a(\s{n_f = e})}}_{\G,\D}(\sigma) \in \MS[\mathrm{Av}]$ of the sequence as follows:
%GDP function $\den{\;}_{\G}(\sigma): \SQ[\mathrm{A_r}] \rightarrow \MS[\mathrm{Av}]$ as follows:
\begin{align*}
\den{\s{n_a(\s{n_f = e})}}_{\G,\D}(\sigma) = \ms(\s{n_a(\s{n_f = \den{e}_{\G}(\sigma)})}
\end{align*}

\subsubsection*{Rules}
\label{sec:ruleSem}
Rules induce  (stochastic) reactions, and we discuss those first. A \emph{reaction} is a structure $\rho \, = \, l \xrightarrow{k} r$ with $l, r$ states and $k$ a positive real number. We will assume that these names also act as accessors for the parts of the reaction structure, so for a reaction $\rho$, $l(\rho)$ returns its left-hand side and so on. We can apply the  reaction $\rho$ to a state $s$ if $l(\rho) \preceq s$, when we obtain a new state  $s - l(\rho) + r(\rho) $, which we write as $\rho \bullet s$.

%Reactions give rise to \emph{stochastic matrices}  on $\ms[\mathrm{Av}]$. 
A \emph{stochastic matrix} (aka \emph{rate function})  over a set of states $S$ is a function $Q: S \times S \rightarrow \mathbb{R}_+$ with $Q$ %is required to be non-negative off the diagonal, 
zero on all but finitely many entries of any row. %, and  with the sum of its entries on any row required to be zero. 
Note that the sum of two stochastic matrices is also a stochastic matrix, as is the zero matrix.  
We will use  stochastic matrices over $\MS[\mathrm{Av}]$ to encode the rate at which reactions occur in different states.  

The rate at which a  reaction $\rho$ occurs in a state $s$ depends on the number of ways in which $l(\rho)$ occurs in $s$.
For any set $A$, we define the \emph{multiplicity} of a submultiset $m \in \MS[A]$ of another  multiset $m' \in \MS[A]$ as the number of distinct times $m$ appears as a submultiset of $m'$, 
%. If we take a multiset $m : X \rightarrow \mathbb{N}$ to be a function from an underlying set $X$ to the natural numbers then the multiplicity of $m$ in $m'$ written as $\mu(m, m')$ is 
defined as:
%
$$
\mu(m, m') = \prod_{a \in m}  \binom{m'(a)}{m(a)}
$$
%$$
%\mu(m, m') = \prod_{x \in X} (m'(x))_{m(x)}
%$$
%where $(n)_k = n \cdot (n-1) \cdot (n-2) \dots (n-k+1)$ is the falling factorial (taken to be 1 when k = 0). 
Consider for example multisets
% (given as their sequence of elements)
 $m = \m{a, a, b}$ and $m'= \m{a_1, a_2, a_3, b}$ where we label the $a$'s in $m'$ to distinguish them. 
 %
 The multiplicity of $m$ in $m'$ is three as $m$ appears as a submultiset of $m'$ in three distinct ways:
$$
\mu(m, m') = |\{ \m{a_1, a_2, b}, \m{a_1, a_3, b}, \m{a_2, a_3, b} \}|$$
%The multiplicity of $m$ in $m'$ is 6 as $m$ appears as a submultiset of $m'$ in 6 distinct ways:
%$$
%\mu(m, m') = |\{ \m{a_1, a_2, b}, \m{a_1, a_3, b}, \m{a_2, a_3, b}, \m{a_2, a_1, b}, \m{a_3, a_1, b}, \m{a_3, a_2, b} \}|$$



%We can now define the stochastic matrix  $Q_{\rho}$ associated to a reaction $\rho = l \xrightarrow{k} r$ by stipulating that we have
%%
%$$Q_{\rho}(s, s') = \left \{ \begin{array}{ll}
%k \cdot \mu(l, s)  & (l \preceq s, s' = \rho \bullet s) \\
%0 & (\mbox{otherwise})\end{array}\right .$$
%%
% off the diagonal.



%Applying reaction $\rho$ to a multiset of agents $s$ gives a new multiset $s' = s \dotminus l(\rho) + r(\rho) $. Note that we write $\dotminus$ for the %point-wise difference between the multiplicities of elements in two multisets; this is not the usual difference operation on multisets. We  write  $\rho \bullet s$ %for the multiset resulting from the application of a reaction $\rho$ to a multiset $s$.

%GDP This did not make sense to me?? Rules abstract over a possibly infinite multiset of reactions. 
With these preliminaries out of the way, we can define the semantics of rules as stochastic matrices on  $\MS[\mathrm{Av}]$, given suitable environments.  
%Given a declarationof values to the variables occurring in a rule,  it can be instantiated to a particular concrete reaction. To evaluate rules to reactions, 
Suppose that we are given a rule typing  %valid in an environment $\G$: 
$\G\,|\, \D \vdash \s{a_l} \xrightarrow{e_r} \s{a_r} \; [e_c]$. Then we further have $\D \vdash \s{a_l} : \G'$ for a unique $\G'$. 
We also have
$\overline{\G} \vdash e_r : \mathrm{real}$, $ \overline{\G}|\D \vdash \s{a_r}$, and $ \overline{\G} \vdash e_c : \mathrm{bool}$, where $\overline{\G} =   \G[\G']$.

%Then for any $\G$-environment $\sigma$ %and $\D$-environment $\sigma'$ 
%we set:
% that takes as from rules to reactions as follows:
%GDPan evaluation function $\den{\;}(\sigma, \sigma'): R \rightarrow \mathcal{R}$ that takes as from rules to reactions as follows:
%\[
%\den{\s{a_l} \xrightarrow{e_r} \s{a_r} \, [e_c]}(\sigma) = 
%%
%\sum \{Q_{\den{a_l}(\sigma') \xrightarrow{\den{e_r}(\sigma[\sigma'])} \den{a_r}(\sigma[\sigma']) } \mid \sigma' \mbox{ a } \D\mbox{-environment}, 
%\den{e_r}(\sigma[\sigma']) \geq 0, \den{e_c}(\sigma[\sigma']) = \mytt\}
%%
%\]

%\[\begin{array}{lcl}
%	\den{\s{a_l} \xrightarrow{e_r} \s{a_r} \, [e_c]}_{\G,\D}(\sigma)  & =  &  
%%
%\sum \{Q_{\den{a_l}_{\D}(\sigma') \xrightarrow{\den{e_r}_{\overline{\G}}(\overline{\sigma})} \den{a_r}_{\overline{\G},\D}(\overline{\sigma}) } \mid \sigma' 
%\mbox{ a } \G'\mbox{-environment}, \overline{\sigma} = \sigma[\sigma'], \\&& 
%                                                                                       \qquad  \qquad  \qquad   \qquad  \qquad  \quad \;\; \;\den{e_r}_{\overline{\G}}(\overline{\sigma}) > 0, 
%\den{e_c}_{\overline{\G}}(\overline{\sigma}) = \mytt\}
%%
%\end{array}
%\]

%\[
%\den{\s{a_l} \xrightarrow{e_r} \s{a_r} \, [e_c]}(\sigma, \sigma') \simeq \left\{ 
%\begin{array}{ll}
%\den{a_l}(\sigma, \sigma') \xrightarrow{\den{e_r}(\sigma')} \den{a_r}(\sigma[\sigma'])  &  (\den{e_c} (\sigma[\sigma']) = \mytt)\\
%\text{undefined } & (\text{otherwise})
%\end{array}
%\right .
%\]
%GDP\begin{align*}
%\den{\s{a_l} \xrightarrow{e_r} \s{a_r} \, [e_c]}(\sigma, \sigma') = \den{a_l}(\sigma, \sigma') \xrightarrow{\den{e_r}(\sigma, \sigma')} \den{a_r}
%(\sigma, \sigma') \, , \, \text{if } \, \den{e_c} (\sigma, \sigma')
%\end{align*}

%We can explain this stochastic matrix in terms of the set of reactions generated by the rule, given a $\G$-environment $\sigma$. Set
%

%
%\[\begin{array}{lcl}\mathcal{R}\den{
%{\s{a_l} \xrightarrow{e_r} \s{a_r} \, [e_c]}}_{\G,\D}(\sigma) & =  &
%\{\den{a_l}_{\D}(\sigma') \xrightarrow{\den{e_r}_{\overline{\G}}(\overline{\sigma})} \den{a_r}_{\overline{\G},\D}(\overline{\sigma}) 
%                                    \mid  \sigma' \mbox{ a } \G'\mbox{-environment}, \overline{\sigma} = \sigma[\sigma'],\\
%                                                            &&             \qquad \qquad \qquad \qquad     \qquad \qquad    \qquad       \den{e_r}_{\overline{\G}}(\overline{\sigma}) > 
%0, \den{e_c}_{\overline{\G}}(\overline{\sigma}) = \mytt\}
%\end{array}\]




In order to define the stochastic matrix over $\MS[\mathrm{Av}]$ associated to the rule $ \s{a_l} \xrightarrow{e_r} \s{a_r} \; [e_c]$, we first need to explain when it matches a state and to define the reaction it denotes.
%
For the first, we say  that a $\G'$-environment $\match$ is a \emph{match} for the rule in a state  $s= \m{av_1, \dots,  av_n}$ if
$\den{a_l}_{\D}( \match)$ is a submultiset of $s$. Note that there are only finitely many possible such rule matches.
%
For the second, suppose we are given a $\G$-environment $\sigma$ and a $\G'$-environment $\sigma'$, then we set\hspace{-2pt}
%
\footnote{We use Kleene equality in this definition: for any two, possibly undefined, mathematical expressions $e$ and $e'$, $e \simeq e'$ holds if (i) $e$ is defined if, and only if, $e'$ is defined, and (ii) they are equal if they are both defined.}
%
\begin{equation*}
\mathcal{R}\den{\s{a_l} \xrightarrow{e_r} \s{a_r} \, [e_c]}(\sigma, \sigma') \simeq \left\{ 
\begin{array}{ll}
\den{a_l}_{\D}(\sigma') \xrightarrow{\den{e_r}_{\overline{\G}}(\overline{\sigma})} \den{a_r}_{\overline{\G}, \D}(\overline{\sigma})  &  
                                                                                                                  (\overline{\sigma} = \sigma[\sigma'],  \den{e_r}_{\overline{\G}}(\overline{\sigma}) > 0, \\
  & \den{e_c}_{\overline{\G}}(\overline{\sigma}) = \mytt)\\
\text{undefined } & (\text{otherwise})
\end{array}
\right .
\end{equation*}
%
Note that this reaction only exists if (the denotation of) the rule rate is
positive and (the denotation of) the rule condition holds. In case the reaction
exists and $\sigma'$ is a match for the rule in a state $s$, we say that the match is
a \emph{proper} match for the rule in state $s$, given $\sigma$.
%
We can now define the stochastic matrix associated to the rule, given a $\G$-environment $\sigma$:
%
\begin{equation*}
\begin{split}
    \den{
{\s{a_l} \xrightarrow{e_r} \s{a_r} \, [e_c]}}_{\G,\D}(\sigma) (s,s')  =   \sum\{\den{e_r}_{\overline{ \G}}(\overline{\sigma})\cdot \mu(\den{a_l}_{ \D}(\match),s)\mid 
& \match \mbox{ is a proper match for } a_l \mbox{ in } s,\, \\
& \overline{\sigma} = \sigma[\match], \\
& s' = \mathcal{R}\den{{\s{a_l} \xrightarrow{e_r} \s{a_r} \, [e_c]}}_{\G,\D}(\sigma,\match)\bullet s \}
\end{split}
\end{equation*}
For example, consider the left-hand expression
$\mathrm{A}(\mathrm{a}=x), \mathrm{A}(\mathrm{a}=y)$ and state
$\m{ \mathrm{A}(\mathrm{a}=1),\mathrm{A}(\mathrm{a}=2)}$. We have two distinct
matches $\match_1= \{x \mapsto 1, y \mapsto 2\}$ and
$\match_2 = \{x \mapsto 2, y \mapsto 1\}$.
%
Next, consider the rule
%
\[r \;=\; \mathrm{A}(\mathrm{a}=x),\mathrm{A}(\mathrm{a}=y) \xrightarrow{f(x, y)} \mathrm{A}(\mathrm{a}=x+y), \mathrm{A}(\mathrm{a}=y-1) \: [g(x,y)]\]
%
assumed well-typed given the agent type  environment $A: (a: \mathrm{int})$ and empty base type  environment.
%
Then, assuming, for example, that $f(x,y)$ denotes 3 in $\match_1$ and the
condition $g(x,y)$ holds there, $\match_1$ yields a reaction from our rule $r$,
namely:
%
\[\mathcal{R}\den{r}(\{\},\match_1)      \;=\;       \mathrm{A}(\mathrm{a}=1), \mathrm{A}(\mathrm{a}=2) \xrightarrow{3} \mathrm{A}(\mathrm{a}=3), \mathrm{A}(\mathrm{a}=1)\]
%
Assuming, further, that the condition does not hold in $\match_2$, for the
stochastic matrix of $r$ we will have:
%
\[\den{r}(\{\})(\m{ \mathrm{A}(\mathrm{a}=1),(\mathrm{a}=2)},\m{ \mathrm{A}(\mathrm{a}=3),\mathrm{A}(\mathrm{a}=1)}) = 3\]
%
If, on the other hand, the condition does hold in $\match_2$ and $f(x,y)$ denotes
3 there, then the stochastic matrix of $r$ will have value 6.  Thus we may count
the same reaction several times when applying a rule.

We should remark that there is an alternative way of counting
multiplicities. Rather than regarding two occurrences of the same agent as
identical and using the binomial coefficient to count up to symmetry, one
instead regards them as distinct entities and uses the falling factorial. The
former approach is used in the standard biochemical literature and in stochastic
multiset rewriting~\citep{anderson_continuous_2011, barbuti_intermediate_2009}; the
latter approach is used in the rule-based kappa system~\cite[Section
4.2.3]{danos_rule-based_2008}.
%
In the case of the usual chemical reactions, the two approaches are the same up to a multiplicative change in the reaction rate. However this is not the case for rule-based systems. Consider, for example, a rule with left-hand side $\mathrm{A}(\mathrm{a}=x),\mathrm{A}(\mathrm{a}=y)$, and the state $\m{ \mathrm{A}(\mathrm{a} =1), \mathrm{A}(\mathrm{a} =1), \mathrm{A}(\mathrm{a} = 2)}$.  The two ways of counting multiplicities of the match 
$\{x \mapsto 1,y \mapsto 1\}$, give 1 and 2, whereas for the match  $\{x \mapsto 1,y \mapsto 2\}$ they both give 2. 
 %
Nonetheless, a more complex translation between the two approaches is possible, assuming available a sufficiently rich stock of conditional expressions for rate expressions to distinguish the various possible cases.

\subsubsection*{Stochastic semantics of models}
\label{sec:stoch}
A \emph{continuous time Markov chain (CTMC)} is a tuple $(S, Q, I)$ with $S$ a
set of states, $Q: S \times S \rightarrow \mathbb{R}$ a stochastic matrix on
$S$, and $I \in S$ the initial state.  Basic Chromar models are evaluated as CTMCs
with set of states $\MS[\mathrm{Av}]$, given a suitable environment.
%
So suppose we have a model typing 
$\G \vdash \s{a_d}; \; \mathbf{init}\, (\s{a_r}); \; \s{r}$. Then, for a unique $\D$, we have $\ \vdash \s{a_d}: \D$, $\G \,|\, \D \vdash \s{a_r}$, and $\G \,|\, \D \vdash \s{r}$. 
%
Then, for any $ \G$-environment $\sigma$,  the CTMC associated to the model is:
%
\[\den{ \s{a_d}; \; \mathbf{init}\, (\s{a_r}); \; \s{r}}_{\G,\D}(\sigma) = (\MS[\mathrm{Av}], \sum_{r \in \s{r}} \den{r}_{\G,\D}(\sigma), \den{\s{a_r}}_{\G,\D}(\sigma))\]
%
We remark that, in the implementation of Chromar, the $ \G$-environment needed
for the semantics of a model, is supplied by the Haskell context in which the
model is defined. We also remark that, with this definition, the same reaction
may be counted more than once as it can occur in two different ways, either when
applying a given rule (a possibility noted above), or when applying two
different rules.

\subsection{A simulation algorithm}
If we try to expand basic Chromar rules to the equivalent reactions for
simulation, we may obtain infinitely many reactions (unless we constrain the
types of the attributes in our agent types to be finite). However, for a given
state only finitely many of these reactions will apply, so we can still use the
normal Stochastic Simulation Algorithm (SSA) to get sample paths from the CTMC,
without constraining the available attribute types.

Specifically our algorithm is the usual SSA (direct
method~\cite{gillespie1977exact}), but with an extra step (1) that dynamically
creates the reactions based on the current state of the system. We assume a
model and an environment $\sigma$, as above. The algorithm keeps a state $s$ and a
time $t$, starting with state $s_0 = \den{\s{a_r}}_{\G,\D}(\sigma)$ and an initial time
$0$, then iterates the following sequence of steps as many times as desired.
\begin{enumerate}
\item For current state  $s$,
 generate the multiset of all possible reactions for every rule: 
$$R  = \m{ \mathcal{R}\den{\s{r}.i}(\sigma, m) \; | \; i = 1,\ldots, |\s{r}|, \, m \mbox{ is a proper match of rule $\s{r}.i$ in $s$, given $\sigma$}}$$ 

\item Calculate the total rate $k_T = \sum_{\rho \in R} R(\rho)\cdot (\mu(l(\rho), s)\cdot  k(\rho))$. Halt if this is zero.
\item Pick the waiting time $t_w$ for the next reaction event
from the exponential distribution with cumulative distribution function $F(t) = 1- e^{-k_T t}$.
\item Pick exactly one of the reactions, choosing reaction $\rho \in R$ with probability $\frac{R(\rho)\cdot \mu(l(\rho), s) \cdot k(\rho)}{k_T}$.
\item If reaction $\rho$ is picked then update the state to $s' = \rho \bullet s$, and the time to $t + t_w$.
\end{enumerate}

Note that we take account of the multiplicity of reactions here: the same
reaction can occur from two different rules, or from one rule using different
matches.

\section{Extended Chromar} 
\label{sec:extChromar} 
We now extend basic Chromar to include the fluent and observable features that
were introduced informally in Section~\ref{sec:overview}. Observables and
fluents extend the given set of (\emph{ordinary}) expressions, $e \in E$, to give
what we call \emph{enriched expressions} $e_r$. These consist of ordinary
expressions, fluents and observables, and any combinations of them. Enriched
expressions give access to the current state and time, and so we take the value
of an enriched expression with type $b$ to be a function from states and times
to $\V_b$, rather than an element of $\V_b$ (in the language of intensional
logic we work with their \emph{intensions} rather than their
\emph{extensions}~\cite{Stan,Fit}).

As enriched expressions allow an arbitrary mixing of ordinary expressions,
fluents, and observables, we might have an observable inside a fluent or a
fluent inside an observable and so on. For example we could write:
\begin{equation*}
f(m) \; \mathbf{when} \; nl > 10 \; \mathbf{else} \; f'(m)
\end{equation*}
where $nl$ is an observable for the number of leaves. This might be used to
introduce the crowding effect on rosette leaves; crowding affects the
assimilation rate as it %affects
reduces the photosynthetically active area.

We begin with the syntax of extended Chromar and then proceed to its semantics.

\subsection{Abstract syntax of extended Chromar}
\label{sec:extSyntax}

The grammar and typing rules are given in Figure~\ref{fig:extSyntax}, and we
discuss them next. The discussion begins with enriched expressions and then
moves on to agents, rules, and models. These are much as in basic Chromar, but
adapted to allow enriched expressions; in particular there is a new syntactic
class of declarations that allows (the intensional values of) enriched
expressions to be used in models.

\subsubsection*{Enriched expressions}
\begin{itemize}

\item[-]%\subsubsection*{Ordinary expressions}
 Any ordinary expression $e \in E$
 is an enriched expression (\textsf{ord-expr}, Figure~\ref{fig:extSyntax}). 
%
%\subsubsection*{Where expressions} 
\item[-] Any variable in an enriched expression can refer to (the value of) another enriched  expression  using the \textsf{where} expression. 
%Any expression $e \in E$ can contain another enriched expression, for example a fluent, as long as it is declared as such using the where construct. 
For example we can write $t > 5 \; \mathbf{where} \; t : \mathrm{real} \; \mathbf{is} \; \mathrm{temp}$ to use the $\mathrm{temp}$ fluent inside, in this case,  an ordinary expression. %, in this case coming from the original expression language. 
These expressions %$e$ 
are typed  inside a type environment extended using the type of the enriched expression in the where clause (\textsc{T-Where}, Figure~\ref{fig:extSyntax}). In our examples we generally proceed informally, omitting the where clause and instead using the where clause expression directly; % inside the language expressions, 
for example we might write $\mathrm{temp} > 5$, although that is not officially an enriched expression. 

\item[-] %\subsubsection*{Fluents}
  The \textsf{time}, \textsf{condition}, and \textsf{repeat} expressions are
  fluents. They are used to provide ways of expressing common motifs of
  time-dependent behaviour, and appeared in examples given
  above. % which we have seen before in the examples.
  The $\mathbf{time}$ constructor gives access to time. The $\mathbf{when}$
  $\mathbf{else}$ fluent is used to specify conditional behaviour over time,
  where, if a condition is met, we choose one fluent and, if not, we choose a
  different one. The typing rule \textsc{T-Cond} ensures that the conditional is
  of type $\mathrm{bool}$ and that the two alternatives have the same type; the
  type of the whole expression is then the common type of the two
  alternatives. The $\mathbf{repeatEvery}$ fluent is used to define a repeating
  behaviour over time, where the first enriched expression is the period of the
  cycling and the second is the behaviour to be cycled. The \textsc{T-Repeat}
  typing rule ensures that the first such expression has type $\mathrm{real}$
  since it is meant to denote time; the type of the whole expression is then the
  type of the cycling behaviour.

\item[-]
  The last way to construct enriched expressions is through the
  database-inspired observables expression (\textsf{obs},
  Figure~\ref{fig:extSyntax}). The $\mathbf{select}$ part is followed by a left
  agent expression. This is used to `filter out' all the agents that have the
  agent name of the left agent expression from the current state, while
  producing bindings of the left agent variables to the values of the
  corresponding agent fields. For example, to select only $\mathrm{Leaf}$ agents
  from the state, we write
  $\mathbf{select} \; \mathrm{Leaf}(\mathrm{age} = i, \mathrm{mass} = m)$,
  thereby producing a multiset of bindings of $i$ and $m$ to the values of the
  $\mathrm{age}$ and $\mathrm{mass}$ fields of the selected agents, with one
  such binding for each occurrence of a leaf agent in the state multiset.  Since
  multiple agents can have the same attribute values, we need a mutiset of
  bindings rather than just a set of them.

  The $\mathbf{aggregate}$ part contains an enriched expression $e_r$, used to
  obtain a combining function to `fold' the state, and a second such expression
  $e'_r$, used to obtain the initial value of the folding. The combining function
  takes the field values from each of the bindings produced by the select part
  and an initial value, and returns an update to the folding value. To enable
  this, $e_r$ (but not $e'_r$) is in the scope of the variables %identifiers
  in the left agent expression.

  We remark that it is in typing observables expressions that the need for the
  agent type environment $\D$ arises in the typing rules for enriched
  expressions.

\end{itemize}


\subsubsection*{Agent expressions, rules, and models}
Enriched expressions can appear in the same places where expressions can be expected and can also be bound  to variables in models. In more detail:

\begin{itemize}

\item[-] Regarding agent introduction and left agent expressions, we keep the
  rules \textsc{T-Intro} and \textsc{T-L-Agent} of Figure~\ref{fig:syntax}, but
  do not repeat them in Figure~\ref{fig:extSyntax}. Regarding right agent
  expressions and rules, we adapt the rules \textsc{T-R-Agent} and
  \textsc{T-Rule} of Figure~\ref{fig:syntax} to Figure~\ref{fig:extSyntax} to
  allow enriched expressions to appear in places where expressions are expected:
  in right agent expressions, rates, and conditions.



\item[-] Variables can be bound to the values of enriched expressions so that
  they can be referred to later (\textsf{declare}, Figure~\ref{fig:extSyntax}).
  A declaration $e_d$ produces an environment in which the type of the enriched
  expression is bound to the variable. These environments are used to produce an
  environment from a sequence of declarations; the rule for this
  (\textsc{T-Dec}, Figure~\ref{fig:extSyntax}) takes account of the facts that
  declared variables can be used in subsequent expressions and that the same
  variable may be declared more than once.
%
\item[-] As before, models $m$ have agent declarations, initial states, and
  rules, but may now use enriched expressions, except in the right agent
  expression for the initial state, as it would make no sense to have enriched
  expressions there (for this reason the judgment
  $\G | \D \vdash_{\mathrm{b}} \s{a_r}$ is used in the \textsc{T-Model} rule, with the
  subscript intended to indicate that the judgement is one of basic, not
  extended, Chromar).

  Models additionally have a sequence of declarations, $\s{e_d}$, and the base
  type environment produced by this sequence is added to the initial base type
  environment when checking the rules (\textsf{model def},
  Figure~\ref{fig:extSyntax}).  The environment produced by the declaration
  sequence is given inductively by the following axiom and rule:
%
\[\G|\D\vdash \varepsilon:\varepsilon \quad \frac{
\G | \D \vdash e_d: \G' \quad\G[\G'] | \D \vdash \s{e_d}:\G''}{\G | \D \vdash e_d, \s{e_d}: \G'[\G'']}\]
%
Note that, unlike the cases of agent declarations or rule lhs's, the
environments here are `overlapped' ($\G[\G']$), rather than `conjoined'
($\G,\G'$), as in the rule for sequences of left agent expressions. This is to
enable identifiers bound to enriched expressions declared earlier in a
declaration sequence to be used later in it.
\end{itemize}

\begin{figure}[!h]
\centering
\resizebox{0.85\linewidth}{!}{%
\begin{tabularx}{1.08\textwidth}{llr|c} 
\toprule
\addlinespace[0.25cm]
& \emph{\textsf{Syntax}} & & \emph{\textsf{Typing rules}} \\
& & & \\
%$e_r ::=$ & & \textsf{rich expr:} & \\
%Ordinary expressions
$e_r ::=$  & $e\quad (e \in E)$ & \textsf{ord-expr} & $\inferrule*[Right=(T-OrdExpr)]{\G  \vdash e: b }{\G | \D\vdash e : b}$
%& $id$ & \textsf{ref} & $\inferrule*[Right=(T-Ref)]{ \G | \D(id) = b}{ \G | \D  \D \vdash id : b}$ \\
\\
& & & \\
%Where
& $e'_r \; \mathbf{where} \; id:b \; \mathbf{is} \; e_r$ & \textsf{where} & $\inferrule*[Right=(T-Where)]{  \G | \D \vdash e_r : b \\   \G[id:b] |  \D \vdash e'_r : b'}{ \G | \D \vdash e'_r \; \mathbf{where} \; id:b \; \mathbf{is} \; e_r : b'}$ \\
& & & \\
%Time
& $\mathbf{time}$ & \textsf{time} & $\inferrule*[Right=(T-Time)]{}{ \G |  \D \vdash \mathbf{time} : \mathrm{real}}$ \\
& & & \\
%Conditional
& $e_r \; \mathbf{when} \; e'_r\; \mathbf{else} \; e''_r$ & \textsf{condition} & $\inferrule*[Right=(T-Cond)]{ \G | \D \vdash e_r : b \\
 \G | \D \vdash e'_r: \mathrm{bool} \\\\ \G | \D \vdash e''_r : b}{\G | \D \vdash e_r \; \mathbf{when} \; e'_r \; \mathbf{else} \; e''_r : b}$\\
& & & \\
%Repeat
& $\mathbf{repeatEvery} \; e_r \; e_r'$ & \textsf{repeat} & $\inferrule*[Right=(T-Repeat)]{\G | \D\vdash e_r : \mathrm{real} \\ 
\G | \D \vdash e_r': b}{\G| \D \vdash \mathbf{repeatEvery} \; e_r \; e_r' : b}$ \\ 
%%Aggregate (old)
%& $\mathbf{select} \; n_a \, ; \mathbf{aggregate} \; e_r \; e_r'$ & \textsf{obs} & $\inferrule*[Right=(T-Obs)]{\G \vdash e_r : (\s{n_f:b}) \rightarrow b' \rightarrow 
%b' \\ \G \vdash e_r' : b'}{\G | \D \vdash \mathbf{select} \; n_a \; ; \mathbf{aggregate} \; e_r \; e_r' : b'}$\\
%\addlinespace[-0.1cm]
%& & & $(n_a : (\s{n_f : b})) \in \D$ \\
%& & & \\
& & & \\
%%Aggregate (new)
%& $\mathbf{select} \; n_a \, ; \mathbf{aggregate} \; (\s{id:b}, id':b').\, e_r, \; e_r'$ & \textsf{obs} & 
%  $\inferrule*[Right=(T-Obs)]{\G,\s{id:b}, id':b' \vdash e_r : b' \\ \G \vdash e_r' : b'}{\G | \D \vdash \mathbf{select} \; n_a \; ; 
%\mathbf{aggregate} \; (\s{id:b}, id':b').\, e_r, \; e_r' : b'}$\\
%\addlinespace[-0.1cm]
%& & & ($(n_a : (\s{n_f : b})) \in \D$) \\
& & & \\
%Aggregate (newnew)
& $\mathbf{select} \; a_l; $ & \textsf{obs} & 
  $\inferrule*[Right=(T-Obs)]{\D \vdash a_l : \G' \\\\ \G[\G'[id:b]] \vdash e_r : b \\ \G \vdash e_r' : b}
  {\hspace{-2.5cm} \G | \D \vdash   \mathbf{select} \; a_l; }$\\
%\addlinespace[0.1cm]
& $ \mathbf{aggregate} \; (id:b.\, e_r) \; e_r'$& & $\hspace{1.55cm} \mathbf{aggregate} \; (id:b.\, e_r) \; e_r' : b$ \\ %($id'$ not bound in $\G'$) \\
& & & ($id'$ not bound in $\G'$)\\
& & & \\
% Declaration
$e_d :: =$ & $id = e_r$ & \textsf{declare} & $\inferrule*[Right=(T-Dec)]{\G | \D \vdash e_r : b }{\G | \D \vdash id = e_r: (id:b)}$ \\
&&&\\
% Declarations
%$\s{e_d} ::=$ & $\varepsilon \; \mid \; e_d, \s{e_d}$ & \textsf{declare seq}& $\G|\D\vdash \varepsilon:\varepsilon \quad \inferrule*[Right=(T-Decs)] {
%\G | \D \vdash e_d: \G' \\ \G[\G'] | \D \vdash \s{e_d}:\G''}{\G | \D \vdash e_d, \s{e_d}: \G'[\G'']}$ \\
%& & & \\
% Right Agent
$a_r::=$ & $n_a(\s{n_f=e_r})$ &\textsf{right agent} & 
$\inferrule*[Right=(T-R-agent)]{\G|\D \vdash \s{e_r :b}}
{\G \,|\, \D \vdash n_a(\s{n_f=e_r})}$ \\
%\addlinespace[-0.3em]
& & \textsf{expr}& ($ n_a : (\s{n_f:b}) \in \D$)\\
& & & \\
% Rule
$r ::=$& $\s{a_l} \xrightarrow{e_r} \s{a_r} \; [e'_r]$ & \textsf{rule expr} &  
%
$\inferrule*[Right=(T-Rule)]{\D \vdash \s{a_l} : \G' \\
 \G[\G']|\D \vdash \s{a_r} \\\\ \G[\G']\,|\,\D \vdash e_r : \mathrm{real}  \\ \G[\G']\,|\,\D \vdash e'_r : \mathrm{bool} }{\G \,|\,\D \vdash \s{a_l} \xrightarrow{e_r} \s{a_r} \; [e'_r]}$\\
& & & \\
% Model 
$m :: = $ & $ \s{a_d}; \; \mathbf{init} (\s{a_r}); \; \s{e_d}; \; \s{r}$ & \textsf{model def} & 
$\inferrule*[Right=(T-Model)]{ \vdash \s{a_d} : \D \\  \G| \D  \vdash_{\mathrm{b}} \s{a_r} \\\\ \G | \D \vdash \s{e_d}:\G' \\ \G[\G'] | \D \vdash \s{r}}{\G 
 \vdash  \s{a_d}; \; \mathbf{init} (\s{a_r}); \; \s{e_d}; \; \s{r}   }$  
\\\\
\bottomrule
\end{tabularx}}
\caption{Abstract syntax of enriched expressions and corresponding typing rules.}
\label{fig:extSyntax}
\end{figure}

\subsection{Semantics of extended Chromar}
\label{sec:extSem}
We next give the semantics of Chromar extended with fluents and observables,
beginning with that of enriched expressions and then moving on to the constructs
that use enriched expressions. We need to use functional environments: we say
that $\sigma= id_1:f_1, \dots, id_n:f_n$ is a \emph{functional $\G$-environment} for a base
type environment $\G= id_1:b_1, \dots, id_n:b_n$ if, for $i = 1,\ldots,n$, $f_i$ is a
function from $\MS[\mathrm{Av}] \times \mathbb{R}$ to $\V_{b_i}$. We work with these
environments as we do with others, in particular treating them as finite
functions. Given a functional $\G$-environment
$\sigma= id_1:f_1, \dots, id_n:f_n$ and a state $s$ and a time $t$ we can obtain
a $\Gamma$-environment by setting
$\sigma(s,t) = id_1:f_1(s,t), \dots, id_n:f_n(s,t)$. In the other direction we
can `promote' a $\G$-environment $\sigma= id_1:v_1, \dots, id_n:v_n$ to a
functional $\G$-environment $\up{\sigma} = id_1: f_1, \dots, id_n : f_n$, by setting
$f_i(s,t) = v_i$, for $i = 1,\ldots,n$.

We need some further definitions in order to give the semantics of observables.  
%First, for any sequence $\s{b} = b_1\ldots b_n$ of base types we set  $\V_{\s{b}} = \V_{b_1} \times \ldots \times \V_{b_n}$.
For any basic environment $\G$ we write $\V_{\G}$ for the set of $\G$-environments.
%For any agent type $\s{n_f:b}$, we define a function $sel_{\s{n_f:b}}:{\MS[\mathrm{Av}] \rightarrow \MS[V_{\s{b}}]}$ by:
%%
%\[\sel_{\s{n_f:b}}(s)  = \m{ \s{v} \in \V_{\s{b}}\mid (n_a, \varphi) \in s , \varphi(\s{n_f}) = \s{v} }\]
%%
Then, given any left agent  expression $\D\vdash a_l: \G$, where $a_l = n_a(\s{n_f = id})$, 
%$n_a(\s{n_f = id})$ and sequence $\s{b}$ of basic types of the same length as $\s{n_f = id}$, 
we define a `selection function' 
%
\[\sel_{\D,a_l}:{\MS[\mathrm{Av}] \rightarrow \MS[\V_{\G}]}\]
%
that takes a state and returns a multiset of bindings ($\G$-environments). This multiset has a binding for each matching agent in the state with multiplicity that of the matching agent.
The selection function is defined by:
%
%\[\sel_{\D, a_l}(s)  = \m{\, \sigma \in \V_{\G}\mid \den{a_l}_{\D}(\sigma) \in s }\]
%
%\[\sel_{\D, a_l}(s)  = \m{\, \sigma \in \V_{\G}\mid (n_a, \varphi) \in s ,  \den{a_l}_{\D}(\sigma) = (n_a, \varphi)}\]
%%
%\[\sel_{\D, a_l}(s)  = \m{\, \sigma \in \V_{\s{id:b}}\mid (n_a, \varphi) \in s , \s{\varphi(n_f)} = \s{\sigma(id)}\, }\]
%%
%making use of the semantics of basic Chromar and an informal finite multiset comprehension syntax intended to respect %multiplicities (for which, cf.~\cite{buneman1994comprehension}).
% In terms of multisets as functions, we have: 
%
\[\sel_{\D, a_l}(s) =  \sigma \in \V_{\G} \mapsto s(n_a(\s{n_f =  \sigma(id)}))\]
%
%\[\sel_{\D, a_l}(s)(\sigma) =  s(\den{a_l}_{\D}(\sigma))\]
%making use of the semantics of basic Chromar and 
recalling that we treat finite multisets as functions that have value 0 except at finitely many arguments. In this respect, note that, as required,  $\sel_{\D, a_l}(s)$ is 0 except for finitely many arguments as $s$ is, and the function 
$\sigma \mapsto n_a(\s{n_f =  \sigma(id)})$ is 1-1.

%the agent  $n_a(\s{n_f =  \sigma(id)})$ determines $\sigma$, and so  $\sel_{\D, 
%a_l}(s)$ is 0 except for finitely many arguments as $s$ is, and is thus  a well-
%defined finite multiset.

%\[\sel_{\D, a_l}(s)(\sigma) =  \sum_{(n_a, \varphi) \in \mathrm{Av}} \{s(n_a, \varphi) \mid   \den{a_l}_{\D}(\sigma) = (n_a, \varphi)\}\]
%
%\[\sel_{\D, a_l}(s)(\sigma) =  \sum_{(n'_a, \varphi) \in \mathrm{Av}} \{s(n_a, \varphi) \mid n'_a =  n_a, \s{\varphi(n_f)} = 
%\s{\sigma(id)}\}\]
%
%
%\[\sel_{\D, a_l}(s)(\sigma) =  \sum_{{\tiny \begin{array}{l}(n_a, \varphi) \in \mathrm{Av}\\
%                                                        \s{\varphi(n_f)} = \s{\sigma(id)}  \end{array}}} s(n_a, \varphi)\]





We recall the list folding function (and see \cite{conf/icfp/Hutton98}). Identifying sequences and lists, for any sets $X$, $Y$, combining function $f: X \times Y \rightarrow Y$  and $y \in Y$, we define: 
%
$\fold(u,f,y) \in Y$ by induction on the length of $u$ as follows:
%
\[\fold(u,f,y) =  \left \{\begin{array}{ll}
                                   y & (u = \varepsilon) \\
                                   f(x,\fold(u',f,y)) & (u = xu')
                                 \end{array} \right .\]
%
Under a natural condition on the combining function, we can use list folding to define finite multiset folding. Say that $f: X \times Y \rightarrow Y$ has a \emph{commutative (left) action} if,  for any $x,x'\in X$ and $y \in Y$, we have:
%
\[f(x,f(x',y)) =  f(x',f(x,y))\]
%
For such a function $f$, we can unambiguously define $\fold(m,f,y)$, for a finite multiset $m \in \MS[X]$, to be $\fold(u,f,y)$, choosing any $u \in \SQ[Y]$ such that $\ms(u) = m$. 

Finally we assume available a `linearisation function'
%
\[\langle\!\langle - \rangle\!\rangle:\MS[\V_{\s{id:b}}] \longrightarrow \SQ[\V_{\s{id:b}}] \]
%
making such a choice for multisets of  $\s{id:b}$-environments. It puts the elements of a finite multiset of $\s{id:b}$-environments in some standard order, repeating them according to their multiplicity, so that $\ms(\langle\!\langle m \rangle\!\rangle) = m$ holds for any $m \in \MS[\V_{\s{id:b}}]$.


\subsubsection*{Semantics of enriched expressions}

%Whereas the semantics of  ordinary expressions $e$ with typing $ \G \vdash e:b$ depends only on $ \G$-environments, the semantics of enriched %expressions depends additionally on states and times. 


As discussed above we take the values of enriched expressions to be functions of
states and time.  So, suppose that we have a typing $\G|\D \vdash e_r$ of an enriched
expression $e_r$. Then for any functional $\G$-environment $\sigma$, we define its
evaluation
$\den{e_r}_{\G,\D}(\sigma): \MS[\mathrm{Av}] \times \mathbb{R} \rightarrow \V_b$ as follows, where we
divide the definition into cases according to the form of the enriched
expression:

%Enriched expressions denote functions from the state (multiset of agents) and time to base values in $V$. The semantics of enriched expressions, $
%\den{e_r}(\sigma)$ take a simple base environment $\sigma=(id_1: v_1, \dots, id_n:v_n)$ containing bindings of identifiers to base values in $V$ and 
%returns a function $\mathcal{M}[Av] \times \mathbb{R} \rightarrow V$ from the state and time to a base value. We write $s$ for states and $t$ for time. 


\begin{align*}
%ordinary expressions
& \den{e}_{\G,\D}(\sigma ) (s, t) = \den{e}_{\G}(\sigma(s,t)) \\[0.2cm]\\
%& \den{id}_{\G,\D}(\sigma ) (s, t) = \sigma_e(id ) (s, t) \\[0.2cm]
%where 
&\den{e'_r \; \mathbf{where} \; id:b \; \mathbf{is} \; e_r}_{\G,\D}(\sigma )  = \den{e'_r}_{\G,\D}(\sigma[x \mapsto \den{e_r}_{\G|\D}(\sigma )]) \\[0.2cm]\\
%time
& \den{\mathbf{time}}_{\G,\D}(\sigma ) (s, t) = t \\[0.2cm]
%when
& \den{e_r \; \mathbf{when} \; e'_r \; \mathbf{else} \; e''_r}_{\G,\D}(\sigma ) (s, t) \;  = \; 
\left \{ \begin{array}{ll}
\den{e_r}_{\G,\D}(\sigma ) (s, t)  & (\mbox{if } \den{e'_r}_{\G|\D}(\sigma ) (s, t) = \mytt) \\[0.2cm]
\den{e''_r}_{\G,\D}(\sigma ) (s, t)  & (\mbox{otherwise})\end{array} \right . \\[0.2cm]\\
%repeat
& \den{\mathbf{repeatEvery} \; e_r \; e_r'}_{\G,\D}(\sigma ) (s, t) = 
          \left \{\begin{array}{ll}    
                       \den{e_r'}_{\G,\D}(\sigma) (s, t') & (\den{e_r}_{\G,\D}(\sigma ) (s, t) > 0)\\
                       0 & (\mbox{otherwise})
                               \end{array}
                      \right . \\[0.2cm]                  
&\hspace{10pt} \mbox{where } t' = t \; \; \mathrm{mod} \; \; \den{e_r}_{\G,\D}(\sigma ) (s, t) \\ \\
&\den{\mathbf{select} \; a_l;\; \mathbf{aggregate} \; ( id:b.\, e_r) \; e_r'}_{\G,\D}(\sigma)(s,t) = \fold(\langle\!\langle
 \sel_{\D,a_l}(s)\rangle\!\rangle, f, \den{e'_r}_{\G,\D}(\sigma)(s,t)) \\
&\hspace{10pt} \mbox{where }\D \vdash a_l:\G' \mbox{ and:} \\
&\hspace{50pt} f(\sigma',v) = \den{e_r}_{\G[\G'[ id:b]],\D}(\sigma[\sigma'[id:v]])(s,t) \quad (\sigma': \V_{\G'}, v : \V_{b})\\
\end{align*}
Here:

\begin{itemize}

\item[-] Ordinary expressions, $e \in E$, are evaluated using the provided evaluation function. 


\item[-] Enriched expressions $e_r' \; \mathbf{where} \; id:b \; \mathbf{is} \; e_r$
are evaluated by evaluating the first expression $e'_r$ in a functional environment in which $id$ is bound to the evaluation of the second expression $e_r$.

\item[-] The time expression is evaluated by returning the given time (so ignoring the environment and the state).

\item[-] The conditional expression is evaluated by evaluating the first expression if the second expression (the condition) evaluates to true, and otherwise  by evaluating the third expression. 

\item[-] The expression $\mathbf{repeatEvery} \; e_r \; e_r'$ is evaluated at time
  $t$ by evaluating $e_r'$ at $t$ modulo the evaluation of $e_r$ at $t$, if the
  evaluation of $e_r$ is $>0$, and returning $0$, if the evaluation of $e_r$ at
  $t$ is $\leq 0$. While the semantics always gives a result, it is only sensible
  if $e_r$'s value is not $0$; a more complex semantics for Chromar would produce
  an error in that case.

\item[-] 

  Finally, given a state, the observable expression
  $\mathbf{select} \; a_c; \; \mathbf{aggregate} \; (id:b.\,e_r) \; e_r'$ is
  evaluated in two stages.  First, the left agent expression
  $a_l = n_a(\s{n_f = id})$ is used to filter out all the $n_a$ agents from the
  state and transform them into environments holding the field values of the
  agent; this produces a multiset of such environments. Second, the value of the
  observable expression is produced by a fold on this multiset. The fold uses a
  combining function obtained from the semantics of $e_r$, and an initial value
  given by evaluating $e'_r$. Note that it employs the linearisation function
  $\langle\!\langle - \rangle\!\rangle$ assumed above. While the semantics gives a result for every such
  combining function, the result of such a fold using a fixed, but arbitrary,
  selection function, is only sensible if the combining function has a
  commutative left action. We leave it to the programmer to make sure their
  combining function has such an action.
\end{itemize}


\subsubsection*{Declarations}
Declarations $id = e_r$ bind the values of enriched expressions $e_r$ to variables
$id$.  A series of such expressions evaluates to an environment binding the
variables to the values of the corresponding enriched
expressions.

So, for a single declaration $\G | \D \vdash id = e_r: (id:b)$, for every functional
$\G$-environment $\sigma$, we define its evaluation
$\den{id = e_r: (id:b)}_{\G ,\D}(\sigma)$ as a functional $id:b$-environment as follows:
%
\begin{align*}
\den{id = e_r}_{\G,\D}(\sigma) = (id : \den{e_r}_{\G,\D}(\sigma))
\end{align*}
%
and for a sequence of declarations $\G | \D \vdash \s{e_d}:\G'$, for every functional
$\G$-environment $\sigma$, we define its evaluation
$\den{\s{e_d}}_{\G , \D}(\sigma)$ as a functional $\G'$-environment as follows:
%
\[\den{\s{e_d}}_{\G , \D}(\sigma) = 
\left \{\begin{array}{ll}
 \varepsilon & (\s{e_d} = \varepsilon)   \\
\den{e'_d}_{\G,\D}(\sigma) [ \den{\s{e''_d}}_{\G[\G'],\D} (\sigma[\den{e'_d}_{\G,\D}(\sigma)]) ] & (\s{e_d} = e'_d \s{e''_d},\, \G|\D \vdash e'_d: \G') 
\end{array}\right .\]
%
Note that this definition recurses on $\s{e_d}$, but, by induction on the length
of $\s{e_d}$, is nonetheless proper.


\subsubsection*{Agents, Rules, and Models}  
Enriched expressions can appear in places where simple expressions appeared:
right agent expressions, conditions, and rates. This does not change our
semantics except that the semantics of all the constructs that involve the
enriched expressions have to be parameterised by state and time since their
evaluation will depend on those.

The semantics of sequences of left agent expressions is the same as that of
basic Chromar. For right agent expressions we make the evident change to
accommodate enriched expressions. To this end, to evaluate sequences of right
agent expressions as states, %to multisets of agents,
suppose that we have a right agent expression typing
$\G \,|\, \D \vdash \s{n_a(\s{n_f = e_r})}$. Then for any functional
$\G$-environment $\sigma$, state $s$, and time $t$, we define its evaluation
$\den{\s{n_a(\s{n_f = e_r})}}_{\G,\D}(\sigma,s,t) \in \MS[\mathrm{Av}]$ as follows:
\begin{align*}
\den{\s{n_a(\s{n_f = e_r})}}_{\G,\D}(\sigma,s,t) = \ms(\s{n_a(\s{n_f = \den{e_r}_{\G,\D}(\sigma)(s,t)})}
\end{align*}

For the semantics of rules, suppose that we are given a rule typing
$\G\,|\, \D \vdash \s{a_l} \xrightarrow{e_r} \s{a_r} \; [e'_r]$. Then we further
have $\D \vdash \s{a_l} : \G'$ for a unique $\G'$.  We also have
$\overline{\G}|\D \vdash e_r : \mathrm{real}$,
$ \overline{\G}|\D \vdash \s{a_r}$, and
$ \overline{\G}|\D \vdash e'_r : \mathrm{bool}$, where $\overline{\G} = \G[\G']$.

For the reaction denoted by the rule, suppose we are given a functional
$\G$-environment $\sigma$, a $\G'$-environment $\sigma'$, and a state $s$ and a time
$t$. Then we set
\begin{equation*}
\mathcal{R}\den{\s{a_l} \xrightarrow{e_r} \s{a_r} \, [e'_r]}(\sigma, \sigma', s, t) \simeq \left\{ 
\begin{array}{ll}
\den{\s{a_l}}_{\D}(\sigma') \xrightarrow{\den{e_r}_{\overline{\G},\D}(\overline{\sigma})(s, t)} \den{\s{a_r}}_{\overline{\G}, \D}(\overline{\sigma}, s, t)  &  \! \big(\overline{\sigma} = \sigma[\up{\sigma'}],  \\ 
  & \den{e_r}_{\overline{\G},\D}(\overline{\sigma})( s, t) > 0, \\ 
  & \den{e'_r}_{\overline{\G},\D}(\overline{\sigma})( s, t) = \mytt \big) 
 \\
\text{undefined } & (\text{otherwise})
\end{array}
\right .
\end{equation*}

Regarding matches, we say that a $\G'$-environment $\match$ is a \emph{proper
  match} of the rule in a state $s$, given a functional $\G$-environment
$\sigma$ and a time $t$, if $\den{a_l}_{\D}( \match)$ is a submultiset of $s$, and
$\mathcal{R}\den{\s{a_l} \xrightarrow{e_r} \s{a_r} \, [e'_r]}(\sigma, m, s, t) $
exists (i.e., $ \den{e_r}_{\overline{\G},\D}(\overline{\sigma})( s, t) > 0$ and
$\den{e'_r}_{\overline{\G},\D}(\overline{\sigma})( s, t) = \mytt $, where
$\overline{\sigma} = \sigma[\up{m}]$).


The stochastic matrix denoted by the rule, given a functional $\G$-environment $\sigma$ and a time $t$, is:
\begin{equation*}
\begin{split}
\den{
{\s{a_l} \xrightarrow{e_r} \s{a_r} \, [e'_r]}}_{\G,\D}(\sigma, t) (s,s') = & \sum\{\den{e_r}_{\overline{ \G},\D}(\overline{\sigma})(s, t) \cdot \mu(\den{a_l}_{ \D}(\match),s) \mid \\
 & \hspace{2.0cm} \match \mbox{ is a proper match for } a_l \mbox{ in } s,\\ 
 & \hspace{2.0cm} \overline{\sigma} = \sigma[\up{ \match}],   \\
 & \hspace{2.0cm} s' = \mathcal{R}\den{{\s{a_l} \xrightarrow{e_r} \s{a_r} \, [e'_r]}}_{\G,\D}(\sigma,\match, s, t) \bullet s \}
\end{split}
\end{equation*}

Turning to models, suppose we have a model typing
$\G \vdash \s{a_d}; \; \mathbf{init}\, (\s{a_r}); \, \s{e_d};\, \; \s{r}$.
Then, for a unique $\D$ and $\G'$, we have $\ \vdash \s{a_d}: \D$ and
$\G | \D \vdash \s{e_d}:\G' $, and then also
$\G | \D \vdash_{\mathrm{b}} \s{a_r}$ and $\overline{\G} | \D \vdash \s{r}$, where
$\overline{\G} = \G[\G']$.
%
Then, for any $\G$-environment $\sigma$ and time $t$ the CTMC associated to the model is:
%

\[\den{ \s{a_d}; \; \mathbf{init}\, (\s{a_r}); \; \s{e_d}; \; \s{r}}_{\G,\D}(\sigma,t) \; =  \; 
                 (\MS[\mathrm{Av}], \sum_{r \in \s{r}} \den{r}_{\overline{\G},\D}(\up{\sigma}[\den{\s{e_d}}_{\G,\D}(\up{\sigma})],t), \den{\s{a_r}}_{\G,\D}(\sigma))\]
%
               where we use the semantics of basic Chromar for the evaluation of
               the basic Chromar initial state right agent expression $a_r$.
               
\subsection{A simulation algorithm}
\label{sec:simT}
Using fluents means that the Continuous Time Markov Chain that a Chromar model
generates becomes inhomogeneous in time. Therefore the standard Stochastic
Simulation algorithm (SSA) does not apply since it assumes constant propensities
between reactions. In practice, however, this discrepancy is often not
prohibitive and gives very similar results while avoiding the extra
computational cost added by non-homogeneity (we discuss this further below).


We therefore use an approximate simulation method where the fluents, and
therefore all time-varying expressions in rules, are only evaluated at the times
the usual SSA would choose for the next reaction. This is equivalent to keeping
their values constant between reactions, at the expense of accuracy. The only
change in our algorithm from that for basic Chromar is then in the reaction
generation step (1) where the reaction generation happens at the current state
and time in an environment extended with the evaluation of defined enriched
expressions.


So assume a model and an environment $\sigma$, as above, and set $\sigma'$ to be the
functional $\G$-environment $\up{\sigma}[\den{e_d}_{\G,\D}(\up{\sigma})]$. As before, the
algorithm keeps a state $s$ and a time $t$, starting with state
$s_0 = \den{\s{a_r}}_{\G,\D}(\sigma)$ and an initial time $0$. It then iterates the same
sequence of steps as before, as many times as desired, except that step (1) is
changed to

\begin{itemize}
\item[1.]  For current state  $s$ and current time $t$, 
 generate the multiset of all possible reactions for every rule:
 \begin{equation*}
 \begin{split}
R  = \m{ \mathcal{R}\den{\s{r}.i}(\sigma', m, s, t) \; | \; & i = 1,\ldots,|\s{r}|, \\ 
                                 & m \mbox{ is a proper match of rule $\s{r}.i$ in $s$}, \\ 
                                 & \mbox{ given $\sigma'$ and $t$}}
\end{split}
\end{equation*}
\end{itemize}

Since fluents are only sampled according to the discrete time-jumps followed by
the simulation clock that means that in practice we only get a discrete
approximation of the continuous functions denoted by the fluent definitions (see
for example Figure~\ref{fig:fluentSamp}). The accuracy of the approximation will
depend on the sampling interval and how fast the fluent changes. If, for
example, the fluent changes on a faster timescale than that of the model then
the approximation will be poor. In practice, however, the fluents are usually on
the same or a slower timescale than that of the model since they are usually
used to model the physical context of the model, which means we get acceptable
approximations. In the case of boolean fluents (like our light fluent from
Figure~\ref{fig:fluentSamp}) similar decisions on how to handle discontinuous
changes have to be made in, for example, simulators that support SBML events. A
common approach there is to have explicit handling of events in the simulation
loop. The stochastic simulation in the iBioSim tool, for example, checks the
time of the next event and executes it if it happens before the time of the next
reaction \citep[see][Algorithm 7]{watanabe_hierarchical_2014}. It should be
possible to extend these methods to Fluents of any type and add to our
simulation algorithm if increased accuracy is needed. We note too that there are
promising new methods for simulating CTMCs with time-varying propensities that
alleviate some of the computational cost \citep{voliotis_stochastic_2016}.

\begin{figure}[tb]
\centering
\includegraphics[width=0.8\textwidth]{figures/fluentSample.png}
\caption{ Ideal (solid line) versus practical approximation during simulation
  (dotted line) of the fluent for the light conditions in a day:
  $ \mathrm{True} \; \mathbf{when} \; (6 < \mathbf{time} < 18) \; \mathbf{else}
  \; \mathrm{False}$, where we take $\mathrm{True}$ to be $1.0$ and
  $\mathrm{False}$ to be $0.0$. The fluent definition denotes a continuous
  function of time but in practice the function will only be sampled at the time
  points the SSA visits (red points). This means that practically we only get a
  discrete approximation of the fluent.}
\label{fig:fluentSamp}
\end{figure}

\section{Conclusion}
Here we defined the formal syntax and semantics of Chromar.


\singlespace


\printbibliography[heading=bibintoc]

%% ... that's all, folks!
\end{document}