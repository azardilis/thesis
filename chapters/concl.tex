After a brief summary of the work presented in this thesis, I next go through
and discuss aspects of my work in order to understand its limitations,
implications that follow, and possible future work that it suggests.

\section{Summary}
% summary
No complex system can be understood by extrapolation of the properties of its
elementary components. In order to understand a complex system, like an
organism, one needs to consider explanations at various levels of detail. This
is especially true in biological systems where entities (processes and so on)
and their organisation give rise to properties of processes at the next level of
detail and they in turn to the next until you get to the level of a living
entity, the organism. In order to understand the organism (and consequently
life) we therefore need to understand the links between the explanations at the
various levels of detail.

The importance of organisation between components has been stressed before and
it is in fact the fundamental concept of systems theory. The stress on
organisation and its constructive nature also leads to questions about
representation. Abstraction to quantifiable properties alone is not adequate to
represent the rich organisation of biological systems. I presented
\emph{Chromar} a language that combines organisational aspects through the
explicit representation of discrete entities, agents, and non-organisational
aspects through abstract properties of these entities, attributes. The concept
of abstraction is there in extensions to the expression language used for the
dynamics of the attributes. Observables recognise the need for explanations at
different levels by allowing an explicit functional link between abstract
quantifiable properties and more explicit representations. Fluents, again, allow
abstraction via the description of system properties using time-dependent
deterministic value for describing parts of the system we do not wish to model
mechanistically.
% While the focus in
% Biology has been traditionally on single components the systems view has found
% its way into mainstream biological thinking with the systems biology
% movement.  The most widely used technical languages for the
% representation of physical systems come from the dynamics world. Since the
% questions there are usually different, abstracting a system to its properties
% through variables and ignoring organisation is usually adequate. The
% constructive organisation of biological systems though poses different
% requirements although the value of abstraction still remains. 

In contemporary plant research the focus has been on the model species
Arabidopsis. Functional-structural models have focused on the constructive
organisation of plant organs (development) as well as functional aspects like
metabolism. The Framework Model \citep{chew_multiscale_2014} is inspired by
these but adds more breadth by explicitly including a genetic circuit and
phenology models to time the conceptual development towards flowering. The FM
covers one part of plant development but does not extend to reproduction, which
means that it has limited applicability in ecological studies. Ecological
studies on the other hand consider the full lifecycle but of an abstract version
of plants where its construction and physical development are absent. I
presented \emph{FM-life} an extension to the FM to the full lifecycle including
reproduction and its scale-up to the population level via a clustering approach
to tractably simulate population of plants over multiple decades in different
genotype x environment scenarios.

Finally, I presented another more engineering oriented use of multi-scale plant
model as devices for optimising plant traits. Instead of the more traditional
genome engineering approach we focused on engineering the environment during
their development to achieve specific growth-related traits.

\section{Chromar and representations of multi-scale biology}
The `structuralists' that we have overviewed in Chapter~\ref{chp:intro} and were
the proponents of organisation and the systems view regarded biology (and life)
as inherently modular with this being a defining (if not the most defining)
characteristic of living systems. Whether biology is inherently modular is
debated \citep{hartwell1999molecular}. %need better ref here!!
Nevertheless, treating as such is a
justifiable choice to advance understanding. Modules includes `visibly'
differentiated substructures like the cell or organs, for example, given in
spatial terms but also other entities that form units in a non-spatial way that
could be identified by the strength of the interactions between their components
or their functional goal. For example, one might identify functional units in
reaction networks \citep{ederer_approach_2003} and hierarchical modules in
metabolic networks \citep{ravasz_hierarchical_2002}. These modules are organised
either by interaction -- more so the case in non-spatial modules -- or by
physical forces -- more the case in spatially distinguished modules like cells
\citep[`Biological and Physical systems' section]{simon1962architecture}.

As we have pointed out, in order to understand complex biological systems, like
entire organisms, we need explanations at multiple levels of detail. At each
level of detail we can identify different modules, which can either be treated
as undivided wholes or as organisations of their elementary components/modules
\citep{varela_autopoiesis:_1974}. The links between the functioning of modules
at different levels of detail are crucial for fundamental questions in
biology. We will call these aspects of biology that deal with modules, their
organisation (interaction), and hierarchy as the \emph{organisational} aspects
of systems. Importantly this organisation changed dynamically.

Explicitly representing the functioning of modules in organisational only terms
in detail, however, is probably impractical in many cases. Even when considering
the elementary components of a module and their organisation, certain aspects of
the functioning of a module are still more practically captured through some
abstraction to pick out properties of interest that perhaps are important for
the links to the next level of detail. The abstraction that one uses to
understand the functioning of a module will depend on the level of understanding
and practical considerations.
%For example, we might not want to describe the
%mechanism of a particular process ('how') but only 'what' it does at a more
%descriptive level.
We will call these the \emph{non-organisational} or
\emph{abstract} aspects of a system (or its model).

Given that in multi-scale explanations of systems require representation of both
non-organisational and organisational aspects, the question of the technical
language used for this representation is interesting. For the organisational
parts since we are considering discrete entities, we need collections of objects
\citep{fontana_barrier_1996}. Other aspects of the organisation possibly also
then need the description of relations on these collections of objects
\citep{rashevsky_topology_1954, rosen_relational_1958}. The constructive nature
of this organisation means that we need a way to describe the
creation/destruction of objects and the creation or deletion of pairings of
objects in the defined relations. In Chromar we have simple representations of
organisational aspects where objects, agents, can be defined along with their
creation/destruction. Explicit definition of relations is not possible, but we
have seen that different kinds of relations on objects exist in object-based
languages (\sct{objectLangs}). Implicit representation is possible through agent
attributes. While possible, this puts an extra burden on the user to first
decide on a representation of the relation through agent attributes and then to
maintain this relation consistent when the state changes when rules are
applied. This burden increases if one needs to keep track of more than one
dynamic relation. This might suggest ways our notation could be
extended. Ideally the language would track such relations and have a special
notation for the most common types of relations -- for example in biology the
`connects-to' and `nested-in' relations seem natural, as we have seen
(\sct{objectLangs}). We could then write rule left-hand sides that say `this
rule is applicable to any two leaves that are connected' or `this rule is
applicable to any two cells inside the same leaf'. A combination of Chromar with
Kappa features resulting in a version of Kappa with richer types, for example,
would be very powerful.

For the non-organisational aspect the question of representation is more
difficult since the point of abstraction is to use the most convenient or
practical explanation for a particular module. Chromar allows agents (modules)
to have attributes, which are lists of typed values. While attributed objects
(colours and so on) have been used in languages before, in Chromar these take an
`elevated' status where they could stand for entire models. Their dynamics come with
discrete transitions, which is the same way the dynamics of objects
(deletion/creation) are defined. This is very general and could satisfy a range
of applications, and we have seen that the Dynamical Grammars of
\citet{mjolsness2006stochastic} also allow the description in terms of the more
familiar ODEs. 

What if we wanted to use the most convenient abstraction for the abstract parts
of each module though? Pragmatic approaches like multi-model simulators
\citep{erbm_mois_2015, cis_2018} allow that through concurrent running of
executables representing the simulation of each module. The organisation of the
modules, for example communicating the level of variables (interaction), is
usually represented externally in a configuration file. While this achieves the
goal of simulation, the resulting multi-model does not achieve the second goal
of models that we have identified regarding understanding since the organisation
is opaque. The connections are merely identification of variables and it is not
clear how these affect each other. Furthermore, these connections are written in
staticcally, which encourages larger modules that are guaranteed to be static.

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.9\textwidth]{figures/hypothetical.eps}
  \caption{A hypothetical system inspired by Chromar that combines
    non-organisational and organisational descriptions. Chromar gives us a clue
    of how these aspects can be combined with enriched expressions. Unlike
    Chromar though we show here a system where relations are explicit and the
    dynamics can be expressed in the most relevant abstraction in each module
    (agent in Chromar).}
    \label{fig:hyp}
\end{figure}

What the above suggest for possible future work is a system that handles both
the organisational aspects in an object-based language and the
non-organisational aspects possibly in many languages. The combination of these
in Chromar through enriched expressions suggests a way that both organisational
and abstract aspects could co-exist naturally in the same system. Consider for
example the system shown in Figure~\ref{fig:hyp}. Like Chromar, the
organisational aspects are represented by discrete objects that have types
(colours in the diagram). Non-organisational aspects exist as part of these
modules to describe aspects of their functioning that we want to capture in a
convenient abstraction. This is like the attributes of agents in Chromar, which
can represent entire models (rectangles attached to objects,
Figure~\ref{fig:hyp}). Different levels of explanation can be combined with
observables, for example a variable in one level might be a function of the
state at another level (dotted line between objects and variables in abstract
models, Figure~\ref{fig:hyp}). Other dynamics can be defined independently of
any module, like Chromar does with fluents ($f$, Figure~\ref{fig:hyp}). Both of
these can coexist with the dynamics of state variables inside each module, in a
similar way that attribute dynamics are given using enriched expressions, which
combine regular expressions, observables, and fluents.

Both the organisational and non-organisational dynamics can be given with rules,
like we have seen with Chromar. The object rules can add/delete or
relate/unrelate objects. Rules can also be used for the interaction of the
internal dynamics of each module. For example, if a state variable from one
module is needed to compute the state variable for another, this interaction can
be captured by synchronising them through a rule. Internal dynamics are captured
through rules referring only to single modules.

Unlike Chromar, however, the abstractions in each module or the independent ones
should be written in any language and explicit relations should also be
representable. In order to achieve this we will either need formal mappings
between the mathematical interpetations of the abstractions used in each module
as suggested by \citet{mjolsness_prospects_2018} or a more pragmatic system
using simulation synchronisation, for example through message passing, which is
the approach taken by \citet{cis_2018}. This does not answer the question of
explicit representation of organisation (through relations) but this could come
from any of the object-based languages we have overviewed that do have these
features (\sct{objectLangs}).

The system of organisation of processes reminds us of the graph of process
interactions of \citet{rashevsky_topology_1954}, who was one of the first to
point to the importance of considering the `relational' aspects of Biology (what
we called organisational aspects here). It is also comparable to the multiscale
topological structures of \citet{godin_multiscale_1998}, which is the main
representation structure used in another tool for simulation of plant systems
based on data-flows on graphs \citep[OpenAlea;][]{pradal_openalea:_2008}.

%\todo{refer to work on previous chapters that motivated observables etc.}

\subsection{Practical considerations}
While there is a lot of work on theoretical aspects of modelling languages,
practical aspects related to the practical use of these languages can be
overlooked especially in more theoretical (modelling) languages from computer
science. This might be because these are usually tied to short-lived research
projects or because there is too much focus on theoretical aspects of these
languages. Some exceptions exist, for example Kappa (\ssec{links}) has seen a
continuous development of a suite of practical tools for its use for a number of
years \citep[Kappa platform;][]{boutillier2018kappa}.

Chromar could similarly benefit from practical tools to overcome practical
hurdles to its use. For example, in the current implementation one would have to
have familiarity with Haskell to write Chromar rules and have the Haskell
ecosystem (compiler and so on) installed to compile models or access the
simulator. Other languages have used more mainstream and familiar languages,
like Python \citep[Kappa or L-systems in Python;][]{lopez_programming_2013,
  boudon2012py} but that still leaves the cost of having a working installation,
which is sometimes prohibitive.

Having these practical tools will be especially important for systems like the
one we outlined in the previous section that allows the combination of multiple
modules. In comprehensive models it is becoming rare that a single person writes
the entire model. A practical modelling tool that combines model definition with
a library of existing modules would be very powerful. This is the approach taken
by simulation frameworks (see \sct{simFrameworks}) in general-purpose
programming languages like CHASTE \citep[suite of software for heart
simulation][]{mirams2013chaste} or APSIM \citep[crop
modelling][]{keating_overview_2003}. Drawing from the ideas in the previous
section and the above framework examples, one could imagine a (possibly visual)
interface where existing or new modules can be connected like jigsaw puzzle
pieces similar to the way programs are defined in visual programming languages
like Scratch \citep{maloney_scratch_2010}. This perhaps could work on the web,
like the Kappa platform, to lower the adaptation curve.

\subsection{Database ideas}
For the observables we use an analogy of the state of the system (multiset of
agent values) to a database. The first part of the observables are defined with
a `select' statement that picks out parts of the state in similarly to the
select statement in database query languages. Similar techniques appear already
in trace-query languages where we have observables over state traces (sequences
of states) instead of single states \citep{laurent_trace_2018}. The left-hand
sides of rules can similarly be thought of as select statements as they pick out
subsets of the state where the transformation represented by the rule can be
applied.

This connection can be exploited to allow the adoption of techniques from
database research for rule-based systems. One area could be to use techniques
from database research to increase the performance of language
implementations. We highlighted some possible ways our implementation could be
improved by avoiding recomputing the matches of each rule at every step of the
simulation (\ssec{simEff}). This is similar to the \emph{view maintenance
  problem}, a well studied problem in database theory. Views are query results
over a database that need to be kept consistent under changes to the underlying
database. There are efficient solutions to the problem for databases with
duplicates (database is taken as a multiset) that could be exploited in the
calculation of our matches to avoid the current naive recomputation at each step
\citep{griffin_incremental_1995}.

Apart from practical results a large amount of theory work also becomes
available, for example for query languages on multisets, which are ubiquitous in
the object-based modelling languages \citep{libkin_query_1997,
  buneman_comprehension_1994}.


%This is the key!!!!!

% made the tie between non-organisational and organisational aspects
% stronger. through fluents and observables
% abstract vs non-abstract spaces
% Make the variables more first-class
% So that they represent whole models perhaps and their connection over multiple
% level of explanation the abstract to the more concrete..enriched expressions
% suggest a way that this could be done
% could be combined

% show how examples to see the challenges to advance their resolution
% refer back to how things in the previous chapter lead to the realisation
% discussed here
% If I had more time + future

% (mention database ideas that could mean borrowing ideas from databases for, say,
% efficient implementation etc.)
% + Laurent paper
% observables over a single agent
% which suggests --->
% --->

% There are ways (see Ricardo's work to abstract a system that includes some form
% of organisation and one level of detail to another.
% Observables are not like that


%\subsection{Multi-scale models that combine}
% What does the Chromar experience suggest?
% Organisational aspects through Chromar or an object-based lang to capture either
% things that we consider objects or abstract objects like processes (see
% Barabasi)
% The non-organisational aspects can be captured in any relevant abstraction
% depending on the level of understanding Can be even treated as undivided wholes
% if needed

% Practically will need either mappings between formalisms or more pragmatically
% something like mois cis\_interface

% mois cis etc. combination of models is not a model!!


\section{Organism-centred evolutionary ecology}
It is not necessary to model everything at the mechanism level ('how' level). If
the intension is to understand at an abstract level what a particular process
does as a computational unit and especially if there is lack of data (or
knowledge) then a more phenomenological description at some abstract level is
adequate and probably even preferable \citep[see levels of description
of][Chapter 1]{marr_vision:_1982}. For example the theory of syntax of
\citet{chomsky_aspects_2014} is a purely computational description of language
and does not describe how this is physically realised in neurons in the brain.

Similarly, many models in plant ecology and evolution abstract away the organism
and have an abstract view of the population as a whole. Understanding the
mechanism though is also important. This has always been true but recent
advances in understanding, the availability of detailed datasets across scales
along with developments in computational tools (\eg high-performance computing)
make this practically achievable \citep{zhu_plants_2016,
  marshall-colon_crops_2017}.

The connections between the abstract computational view of a process and its
physical realisation is vital in answering the 'how' questions of life (see
Introduction, Figure~\ref{fig:circle}). As more knowledge of the mechanism
becomes available for plants, it becomes attractive to replace the abstract with
the mechanistic to get a more mechanistically-founded view of evolutionary
processes, as we have seen in Chapter~\ref{chp:fms}.

On the opposite side of this however, connecting a low-level mechanism up the
scales to the population level might help understand and answer 'why' questions
about the evolution of the mechanism too. If evolution is a population process
\citep{doebeli_towards_2017} then modelling a mechanism in detail in the context
of the organism and the population might explain its evolution
\citep[\enquote{Nothing in biology makes sense except in light of population
  genetics};][]{lynch_origins_2007}.

As we go from individual detailed mechanisms to the population level it is
always important to experimentally test our understanding and hypotheses that we
formalise in models. While common for crop species, they usually only consider only one
generation. The short length of the Arabidopsis lifecycle along with detailed
molecular and genetic data might make it possible to make experiments to see the
links between genomes and the population over multiple generations in natural
conditions.  \citet{rubin_circadian_2018}, for example, do field experiments
(natural weather conditions) with populations of circadian clock mutant
Arabidopsis plants to observe the effect on developmental timing and shoot
architecture. This study is again for a single generation but includes traits
like total fruit mass that could be used as proxies for reproductive success
therefore allowing validation of multi-scale models and the evolutionary
hypotheses they suggest.

% Experimental validation? From genes to populations?

% Effect of one mechanism on context? This theme is also important for the
% previous section, abstract then mechanisms can be added later. It might be
% interesting to see if we understand the effects of a single mechanism on
% higher-levels of organisation.
% Not always at the mechanism level -- see Marr's levels

% Since we're plant biologists and the plant is where we have mechanims information
% we would like to see the effect on ecology.

% Next, including population genetics and genomic variation should give
% understanding of the evolution of the clock gene circuit

% With phenology we kind of understand at the first level, going
% to the second level of mechanism (how this is realised) we need the organism.




% Apart from helping with the how questions by adding mechanism to higher level
% processes, they can also help with why question when considering a particular
% mechanism in detail.

% \section{Multi-scale organism models for engineering}
% Finally,
% for these I'm not sure we need the organism. The organism is there for the
% fundamental questions
% We can engineer the environemnt etc.

% Why do we use a multi-scale detail model?
